<div class="section section-visible" data-id="USFYpDV9" name="versioning package" data-type="package" transient-focussed="true"><div class="paragraph body-paragraph" data-id="CiC6ZNKJ" name="Documentation"><div data-type="content" type="text/html" contenteditable="true" class="section-documentation"></div></div><div class="paragraph data-paragraph" data-id="NKRfAA7M" name="Properties"><pre data-type="content" type="application/json" class="section-properties">{
	"version"    : "0.5.1.0",
	"icon"       : "change_history",
	"description": "a wrapper for core Webstrates api to enable local versioning for code chunks in Codestrates.",
	"tags"       : [
		              "function",
		              "code paragraphs"
	],
	"assets": [
    "lodash.min.js"
	],
	"dependencies": [
    {
      "id": "RAAJuPq8",
      "name": "activityComponent",
      "optional": false,
      "usage": "visualising activities to ease navigation."
    }
  ],
	"changelog":
	{
    "0.5.1.0" : "code refactoring",
    "0.5.0.0" : "data for activity component is prepared upon entering versioning mode",
    "0.4.3.0" : "ADDED: activityComponent dependency",
  	"0.4.2.0" : "FIXED: forward/backward navigation works correctly",
    "0.4.1.0" : "contributor-based navigation",
    "0.4.0.0" : "WiP: navigation via artefacts",
    "0.3.9.5" : "finding ops related to execution state",
    "0.3.9.0" : "UI enter/exit and way to update editor are ready",
    "0.3.8.0" : "ADDED: enter/exit mode function, not finished",
    "0.3.6.0" : "updated UI, ADDED: contributor + curr version indicators",
    "0.3.5.0" : "FIXED: now newly created sections are persistent, commeted part of opsClient",
    "0.3.4.0" : "combining all into a pipeline",
    "0.3.2.0" : "versioning UI only for code chunks, refactoring opsUtils into proper functions",
    "0.3.0.0" : "added coreWebstrateClient API by Kristian Antonsen + helper utils for ops processing",
    "0.2.5.0" : "Updated UI, tested where it is actionable",
    "0.2.0.0" : "Simple UI",
		"0.1.0.0" : "Initial release."
	},
	"github": {
		"url"   : "https://github.com/Stalkcomrade/codestrates-cell-versioning-package",
		"folder": "packages/USFYpDV9-codestrates-cell-versioning-package"
	}
}</pre></div><div class="paragraph code-paragraph collapsed" data-id="zRmB9PSK" last-execution-state="success" name="helperFunctions"><pre data-type="content" type="text/javascript" id="helperFunctions">const compareArrays = (array1, array2) =&gt; {
    return array1.length === array2.length &amp;&amp; array1.every((value, index) =&gt; value === array2[index])
}


const FilterObjectByKey = (obj, key) =&gt; {
    return Object.keys(obj).reduce((acc, val) =&gt; {
        
        if (val !== key) {
            return  {
                ...acc,
                [val]: obj[val]
            }
        } else {
            return acc
        }
    }, {}) // INFO: first value for accumulator
}


const compareSort = (a, b) =&gt; {

    let comparison = 0;
    if (a.version &gt; b.version) {
        comparison = 1;
    } else if (a.version &lt; b.version) {
        comparison = -1;
    }
    return comparison;
}

const uuid = function b(a){return a?(a^Math.random()*16&gt;&gt;a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,b)}


const getRandomArbitrary = (min, max) =&gt; {
    return Math.round(Math.random() * (max - min) + min);
}


exports = Object.assign(exports, {compareArrays, FilterObjectByKey, compareSort, 
                                  uuid, getRandomArbitrary})</pre></div><div class="paragraph code-paragraph collapsed" data-id="55EBLEgB" name="coreWebstratesClientAPI"><pre data-type="content" type="text/javascript" id="coreWebstratesClientAPI">
// coreEvents
const coreEventsModule = {};

// Map from event names to a set of the actual listeners: string -&gt; set of listeners.
const eventListeners = {};
// Map from event names to actual listeners: string -&gt; function.
const addEventListenerListeners = {};
// Map from event names to actual listeners: string -&gt; function.
const removeEventListenerListeners = {};

const priorities = {
	IMMEDIATE: 0,
	HIGH: 1,
	MEDIUM: 2,
	LOW: 3,
	LAST: 4
};

coreEventsModule.PRIORITY = new Proxy(priorities, {
	get: (target, name) =&gt; {
		if (name in target) return target[name];
		throw new Error(`Invalid priority ${name}`);
	}
});

/**
* Create new event.
* @param  {string}  eventName  Event name.
* @param  {object} options     An object of options:
*                              idempotent:      Whether we allow the same event to be created
*                                               multiple times without throwing an error.
*                              addListener:     A callback to be triggered when an eventListener
*                                               gets added.
*                              removeListener:  A callback to be triggered when an eventListener
*                                               gets added.

* @public
*/
coreEventsModule.createEvent = (eventName, options = {}) =&gt; {
	if (coreEventsModule.eventExists(eventName) &amp;&amp; !options.idempotent) {
		throw new Error(`Event ${eventName} already exists.`);
	}

	if (typeof options.addListener !== 'undefined') {
		if (typeof options.addListener !== 'function') {
			throw new Error(`addListener must be a function, received: ${options.addListener}.`);
		}
		addEventListenerListeners[eventName] = options.addListener;
	}

	if (typeof options.removeListener !== 'undefined') {
		if (typeof options.removeListener !== 'function') {
			throw new Error(`removeListener must be a function, received: ${options.removeListener}.`);
		}
		removeEventListenerListeners[eventName] = options.removeListener;
	}

	if (!eventListeners[eventName]) {
		eventListeners[eventName] = new Set();
	}
};

coreEventsModule.eventExists = (eventName) =&gt; eventListeners.hasOwnProperty(eventName);

coreEventsModule.addEventListener = (eventName, eventListener,
	priority = coreEventsModule.PRIORITY.LOW, options) =&gt; {

	eventListener.priority = priority;
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}

	if (eventListeners[eventName].has(eventListener)) {
		throw new Error(`EventListener already attacehd to ${eventName}.`);
	}
	eventListeners[eventName].add(eventListener);
	if (addEventListenerListeners[eventName]) {
		addEventListenerListeners[eventName](eventListener);
	}

};

coreEventsModule.removeEventListener = (eventName, eventListener) =&gt; {
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}
	eventListeners[eventName].delete(eventListener);
	if (removeEventListenerListeners[eventName]) {
		removeEventListenerListeners[eventName](eventListener);
	}
};

coreEventsModule.triggerEvent = (eventName, ...args) =&gt; {
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}

	// Convert set of event listeners to array, so we can sort them.
	const arrEventListeners = Array.from(eventListeners[eventName]);

	// Sort all events by priority (IMMEDIATE, HIGH, MEDIUM, ... ).
	arrEventListeners.sort((e, f) =&gt; e.priority - f.priority);

	// Execute events (in proper order).
	arrEventListeners.forEach(eventListener =&gt; {
		try {
			// IMMEDIATE listeners get triggered right now, everything else happens on the next tick.
			if (eventListener.priority === coreEventsModule.PRIORITY.IMMEDIATE) {
				eventListener(...args);
			} else {
				// It is somewhat counter-intuitive that non-IMMEDIATE listeners gets triggered by
				// setImmediate. setImmediate means "immediately after we're done with everything else".
				setImmediate(eventListener, ...args);
			}
		}
		catch (e) {
			console.error(e);
		}
	});
};

// module.exports = coreEventsModule;
////////////////////////////////////////////////////

// coreUtils

const coreUtilsModule = {};

let locationObject;
/**
 * Parses a query string and returns a more friendly object.
 * @param  {Location} location Location object.
 * @return {object}            Object with webstrateId, tagOrVersion and parameters.
 */
coreUtilsModule.getLocationObject = () =&gt; {
	if (locationObject) {
		return locationObject;
	}

	const pathRegex = /^\/([A-Z0-9._-]+)\/(?:([A-Z0-9_-]+)\/)?/i.exec(window.location.pathname);
	const [ , webstrateId, tagOrVersion] = pathRegex;

	const parameters = {};
	const queryRegex =  /([^&amp;=]+)=?([^&amp;]*)/g;
	const query = window.location.search.substring(1);

	let match;
	while ((match = queryRegex.exec(query))) {
		const [, key, value] = match;
		parameters[key] = decodeURIComponent(value);
	}

	let tag, version;
	if (/^\d/.test(tagOrVersion) &amp;&amp; Number(tagOrVersion)) {
		version = Number(tagOrVersion);
	} else {
		tag = tagOrVersion;
	}

	locationObject = {
		webstrateId,
		staticMode: !!tagOrVersion,
		tagOrVersion,
		tag, version, // Only one of tag/version will be set
		parameters
	};

	return locationObject;
};

/**
 * Creates a throttled version of a function, i.e. one that only runs at most once every N
 * milliseconds.
 * @param  {Function} fn         Source function.
 * @param  {Number}   limit      Execution delay in milliseconds.
 * @return {Function}            Throttled source function.
 * @public
 */
coreUtilsModule.throttleFn = (fn, limit) =&gt; {
	let timeout, lastCall = 0;
	return function(...args) {
		let now = Date.now();
		let delay = lastCall + limit - now;
		if (delay &lt;= 0) {
			fn(...args);
			lastCall = now;
		} else {
			clearTimeout(timeout);
			timeout = setTimeout(() =&gt; {
				fn(...args);
				lastCall = now;
			}, delay);
		}
	};
};

/**
 * Checks for literal equality of objects. This is a stupid way, but it works.
 * @param  {obj} a First object to compare.
 * @param  {obj} b Second object to compare.
 * @return {bool}  True if objects are equal.
 * @public
 */
coreUtilsModule.objectEquals = (a, b) =&gt; JSON.stringify(a) === JSON.stringify(b);

/**
 * Shallow clones an object.
 * @param  {obj} obj Object to be copied.
 * @return {obj}     Shallow clone.
 * @public
 */
coreUtilsModule.objectClone = (obj) =&gt; Array.isArray(obj) ? obj.slice(0) : Object.assign({}, obj);

/**
 * Returns a locked, shallow clone of an object.
 * @param  {obj} obj Object to lock and clone.
 * @return {obj}     Cloned object.
 * @public
 */
coreUtilsModule.objectCloneAndLock = (obj) =&gt; Object.freeze(coreUtilsModule.objectClone(obj));

/**
 * Get random integer from interval [min, max). Unbiased and evenly distributed (or close to).
 * @param  {int} min Minimum number, inclusive.
 * @param  {int} max Maximum number, exclusive.
 * @return {int}     Random number in interval [min, max)
 * @public
 */
coreUtilsModule.random = (min, max) =&gt; {
	return Math.floor(min + Math.random() * (max - min));
};

/**
 * Get random string of size.
 * @param  {int}    size     Expected length of string (optional).
 * @param  {string} alphabet List of characters to be used in string (optional).
 * @return {string}          Generated string.
 * @public
 */
coreUtilsModule.randomString = (size = 8,
	// Does not include 0, O, o, 1, I, l for readability.
	alphabet = '23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ') =&gt; {
	const len = alphabet.length;
	let str = '';
	while (size--) {
		str += alphabet[coreUtilsModule.random(0, len)];
	}
	return str;
};

/**
 * Get child nodes of an element. If the element is a fragment, get the content's child nodes.
 * @param  {DOMElement} parentElement Element to get child nodes of.
 * @return {array}                    List of child nodes.
 */
coreUtilsModule.getChildNodes = function(parentElement) {
	// This will be the case for &lt;template&gt; tags.
	if (parentElement.content &amp;&amp; parentElement.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
		parentElement = parentElement.content;
	}
	return parentElement.childNodes;
};

/**
 * Traverses a node tree and applies a callback to each node.
 * @param {DOMNode}  node     Node tree to traverse.
 * @param {DOMNode}  parent   Initial parent node.
 * @param {Function} callback Callback.
 * @public
 */
coreUtilsModule.recursiveForEach = function(node, callback, parent = null) {
	callback(node, parent);

	Array.from(coreUtilsModule.getChildNodes(node)).forEach(child =&gt; {
		coreUtilsModule.recursiveForEach(child, callback, node);
	});
};


//  * Append a DOM element childElement to another DOM element parentElement. If the DOM element to
//  * be appended is a script, prevent the execution of the script. If the parentElement is a
//  * &lt;template&gt;, add the child to the parentElement's documentFragment instead. If a referenceNode
//  * is specified, the element is inserted before the referenceNode.
//  * @param {DOMNode} parentElement Parent element.
//  * @param {DOMNode} childElement  Child element.
//  * @param {DOMNode} referenceNode Node to insert before.
//  * @public
//
coreUtilsModule.appendChildWithoutScriptExecution = (parentElement, childElement, referenceNode) =&gt;
{
	// We just insert text nodes right away, we're only interested in doing fancy stuff with elements
	// that may have scripts as children.
	if (!(childElement instanceof HTMLElement)) {
		return parentElement.insertBefore(childElement, referenceNode || null);
	}

	// To prevent scripts from being executed when inserted, we use a little hack. Before inserting
	// the script, we replace the actual script with dummy content, causing that to be executed
	// instead of the actual script. If it's an inline script, we insert a script with dummy content
	// ('// Execution prevention'), and then replace the innerHTML afterwards.
	// To prevent issues with any other attributes (e.g. crossorigin and integrity), we also remove
	// all those attributes and insert them later.
	const scriptMap = new Map();
	const scripts = (childElement instanceof HTMLScriptElement) ? [ childElement ]
		: [ ...childElement.querySelectorAll('script') ];

	scripts.forEach(script =&gt; {
		const attrs = [];
		Array.from(script.attributes).forEach(attr =&gt; {
			attrs.push([ attr.nodeName, attr.nodeValue ]);
			script.removeAttribute(attr.nodeName);
		});
		const text = script.innerHTML;
		script.innerHTML = '// Execution prevention';
		scriptMap.set(script, [ attrs, text ]);
	});

	parentElement.insertBefore(childElement, referenceNode || null);

	scripts.forEach(script =&gt; {
		const [ attrs, text ] = scriptMap.get(script);
		attrs.forEach(attr =&gt; {
			const [nodeName, nodeValue] = attr;
			script.setAttribute(nodeName, nodeValue);
		});
		script.innerHTML = text;
	});
};

/**
 * Reinsert and execute an array of scripts in order.
 * @param {array}    scripts  Array of script DOM elements.
 * @param {Function} callback Function to call once all scripts have been executed.
 * @public
 */
coreUtilsModule.executeScripts = (scripts, callback) =&gt; {
	const script = scripts.shift();
	if (!script) {
		return callback();
	}

	// Scripts in templates shouldn't get executed. If we didn't do this, we could also run into
	// issues a little later in the function when we'd attempt to reinsert the element into its
	// parent if the script is a direct child of the template, as such children don't actually have
	// parents.
	if (coreUtilsModule.elementIsTemplateDescendant(script)) {
		return coreUtilsModule.executeScripts(scripts, callback);
	}

	const executeImmediately = !script.src;
	const newScript = document.createElementNS(script.namespaceURI, 'script');
	if (!executeImmediately) {
		newScript.onload = newScript.onerror = function() {
			coreUtilsModule.executeScripts(scripts, callback);
		};
	}

	// Copy over all attribtues.
	for (let i = 0; i &lt; script.attributes.length; i++) {
		const attr = script.attributes[i];
		newScript.setAttribute(attr.nodeName, attr.nodeValue);
	}

	// Copy over all other properties.
	Object.assign(newScript, script);

	// We're defining the wid with defineProperty to make it non-modifiable, but assign will just copy
	// over the value, leaving it modifiable otherwise.
	coreUtilsModule.setWidOnElement(newScript, script.__wid);

	newScript.innerHTML = script.innerHTML;

	script.parentElement.insertBefore(newScript, script);
	script.remove();

	if (executeImmediately) {
		coreUtilsModule.executeScripts(scripts, callback);
	}
};


/**
 * Check whether a DOM Node is a descendant of a template tag (or actually a documentFragment).
 * One might assume this could be done with `element.closest("template")`, but that won't be the
 * case, because a documentFragment technically isn't a parent (and also doesn't have any parent),
 * so there will be no tree to search upwards through after we reach the documentFragment.
 * @param  {DOMNode} DOMNode DOM Node to check.
 * @return {boolean}         True if the DOM Node is a descendant of a template.
 * @private
 */
coreUtilsModule.elementIsTemplateDescendant = element =&gt;
	document.documentElement.ownerDocument !== element.ownerDocument;

/**
 * Check if the current page has been transcluded (i.e. is an iframe)
 * @return {bool} True if this frame is transcluded.
 * @public
 */
coreUtilsModule.isTranscluded = () =&gt; window.frameElement &amp;&amp; window.parent !== window;

/**
 * Check whether the current frame shares domain with the outer frame. Only useful when called
 * when transcluded (i.e. called from an iframe). This is used to determine whether accessing the
 * outer frame will cause CORS errors.
 * @return {bool} True if current and outer frame share domain.
 * @public
 */
coreUtilsModule.sameParentDomain = () =&gt; {
	const a = document.createElement('a');
	a.href = document.referrer;
	return a.host === location.host;
};

/**
 * Removes characters that are illegal in attributes and tag names.
 * @param  {string} tagName Unsanitized string.
 * @return {string}         Sanitized string.
 * @public
 */
coreUtilsModule.sanitizeString = (string) =&gt; {
	// See https://www.w3.org/TR/html5/syntax.html#tag-name and
	// https://www.w3.org/TR/html5/syntax.html#elements-attributes
	// These regex test does not fully adhere to either, but is more stringent to avoid serialization
	// issues.
	var NAME_START_CHAR_REGEX = /:|[A-Z]|_|[a-z]/;
	var NAME_CHAR_REGEX = /-|\.|[0-9]/;

	return string.split('').map(function(char, index) {
		if (NAME_START_CHAR_REGEX.test(char) || (index &gt; 0 &amp;&amp; NAME_CHAR_REGEX.test(char))) {
			return char;
		}
		return '_';
	}).join('');
};

/**
 * Replaces ampersands (&amp;) and double-quotes (") with their respective HTML entities.
 * @param  {string} value Unescaped string.
 * @return {string}       Escaped string.
 * @public
 */
coreUtilsModule.escape = value =&gt; value &amp;&amp; value.replace(/&amp;/g, '&amp;amp;').replace(/"/g, '&amp;quot;');

/**
 * Replaces &amp;amp; and &amp;quot; with their respective characters (&amp; and ").
 * @param  {string} value Escaped string.
 * @return {string}       Unescaped string.
 * @public
 */
coreUtilsModule.unescape = value =&gt; value &amp;&amp; value.replace(/&amp;amp;/g, '&amp;').replace(/&amp;quot;/g, '"');

/**
 * Replaces "." with &amp;dot;.
 * @param  {string} value Unescaped string.
 * @return {string}       Escaped string.
 * @public
 */
coreUtilsModule.escapeDots = value =&gt; value &amp;&amp; value.replace(/\./g, '&amp;dot;');

/**
 * Replaces &amp;dot; with ".".
 * @param  {string} value Escaped string.
 * @return {string}       Unescaped string.
 * @public
 */
coreUtilsModule.unescapeDots = value =&gt; value &amp;&amp; value.replace(/&amp;dot;/g, '.');

const widMap = new Map();
/**
 * Add a wid to a node and make it (easily) non-modifiable.
 * @param  {DOMNode} node Node to set wid on.
 * @param  {string} wid  wid.
 * @public
 */
coreUtilsModule.setWidOnElement = (node, wid) =&gt; {
	widMap.set(wid, node);
	Object.defineProperty(node, '__wid', {
		value: wid,
		writable: false, // No overwriting
		enumerable: true, // Let iterators and Object.assign see the wid.
		configurable: true // Allow us to redefine it in rare race condition scenarios.
	});
};

/**
 * Remove element from wid map. Bye, bye, memory leak!
 * @param  {string} wid wid.
 * @public
 */
coreUtilsModule.removeWidFromElement = wid =&gt; widMap.delete(wid);

/**
 * Get element by wid.
 * @param  {string} wid wid.
 * @return {DOMNode}     DOM Element with given wid.
 * @public
 */
coreUtilsModule.getElementByWid = wid =&gt; widMap.get(wid);

// // module.exports = coreUtilsModule;

// ////////////////////////////////////////

// INFO: corePathTree

// JavaScript code here
// const coreUtils = require('./coreUtils');
const coreUtils = coreUtilsModule;
/*
Webstrates PathTree (webstrates.pathree.js)

PathTree is a tree data structure mapping to the DOM, but with some extended attributes. Each node
in a PathTree consists of a unique id, a list of children, a parent, and the node's mapped DOM
element.

The primary purposes of the PathTree are to:
  1) Maintain a copy of the DOM tree's structure pre-mutation, so operations on the pre-mutation DOM
     tree can be rewritten to work on the post-mutation DOM tree.
  2) Facilitate lightweight creation of JsonML which is used when creating operations that are to be
     sent to the Webstrates server.
  3) Allow for verifying the integrity of the document by comparing every DOM node to its respective
     PathTree node.
*/

/**
 * Generate a unique identifier (UUID4).
 * @return {UUID}
 */
function generateUUID() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
		var r = Math.random() * 16 | 0;
		var v = c === 'x' ? r : (r &amp; 0x3) | 0x8;
		return v.toString(16);
	});
}

/**
 * Create a PathTree from a DOM element. If a parentPathTree is provided, the created
 * PathTree will be a subtree of the parent.
 * @param {DOMNode} DOMNode	DOMNode to create PathTree from.
 * @param {PathTree} parentPathTree	PathTree to add as parent.
 * @param {bool} overwrite	Whether existing PathTree on the DOMNode should be overwritten by the
 * new PathTree or just appended to it.
 * @return {PathTree} Created PathTree.
 */
function PathTree(DOMNode, parentPathTree, overwrite) {
	this.id = generateUUID();
	this.children = [];
	this.parent = parentPathTree;
	this.DOMNode = DOMNode;

	// When moving an element around, a node may exist in two places at once for a brief moment.
	// __pathNodes therefore has to be a list.
	if (overwrite || !DOMNode.__pathNodes || DOMNode.__pathNodes.length === 0) {
		DOMNode.__pathNodes = [this];
	} else {
		DOMNode.__pathNodes.push(this);
	}

	var childNodes = DOMNode.hasChildNodes() ? DOMNode.childNodes :
		(DOMNode.content &amp;&amp; DOMNode.content.childNodes) || [];
	Array.from(childNodes).forEach(function(childNode) {
		var childPathNode = PathTree.create(childNode, this, overwrite);
		if (childPathNode) {
			this.children.push(childPathNode);
		}
	}.bind(this));
}

/**
 * Check whether a DOM Node should be persisted on the server (i.e. whether it's transient or not).
 * For a DOM Node to be transient, it has to be an element (i.e. not a text node), exist outside of
 * a template tag, as well as not be in the list of transient elements (config.transientElements).
 * @param  {DOMNode} DOMNode DOM Node to check.
 * @return {boolean}         True if the DOM Node is transient.
 * @private
 */
function isTransientElement(DOMNode) {
	// Only elements can be transient
	return DOMNode.nodeType === document.ELEMENT_NODE
		// Nothing in templates can be transient
		&amp;&amp; !coreUtils.elementIsTemplateDescendant(DOMNode)
		// Only elements passing a function defined in config.isTransientElement are transient.
		&amp;&amp; config.isTransientElement &amp;&amp; config.isTransientElement(DOMNode);
}

/**
 * Add PathNode to node if the node isn't a &lt;transient&gt; element.
 * @param  {[type]} DOMNode        [description]
 * @param  {[type]} parentPathTree [description]
 * @param  {[type]} overwrite      [description]
 * @return {[type]}                [description]
 */
PathTree.create = function(DOMNode, parentPathTree, overwrite) {
	// Transient elements are not supposed to be persisted, and should thus not be part of the
	// PathTree. Unless the transient element is in a &lt;template&gt;.
	if (isTransientElement(DOMNode) || (!parentPathTree &amp;&amp; DOMNode !== document.documentElement)) {
		return;
	}

	return new PathTree(DOMNode, parentPathTree, overwrite);
};
/**
 * Creates a JsonML representation of the PathTree.
 * @return {JsonML} JsonML representation of PathTree.
 */
PathTree.prototype.toPath = function() {
	if (!this.parent) {
		return [];
	}

	var childIndex = this.parent.children.findIndex(function(sibling) {
		return sibling.id === this.id;
	}.bind(this));

	// In the JsonML representation, the list elements start at position 2 in the object:
	//   [tag-name, attributes, ...element-list]
	var ELEMENT_LIST_OFFSET = 2;
	return [...this.parent.toPath(), ELEMENT_LIST_OFFSET + childIndex];
};

/**
 * Remove a PathTree by removing itself from parent as well as removing all children.
 * @param {bool} shallow Does not remove itself from parent if true (deletion if shallow).
 * @return {PathTree}    The deleted PathTree, consisting only of an object with an id.
 */
PathTree.prototype.remove = function(shallow) {
	// TODO: Why can't we do this EVERY time? If we do this on the children as well, the integrity
	// check fails.
	if (!shallow) {
		// Remove ourselves from our parent.
		this.parent.children.splice(this.parent.children.indexOf(this), 1);
	}
	this.parent = null;

	// Remove ourselves from our DOMNode.
	this.DOMNode.__pathNodes.splice(this.DOMNode.__pathNodes.indexOf(this), 1);
	this.DOMNode = null;

	// Remove all our children.
	this.children.forEach(function(child) {
		child.remove(true);
	});
	this.children = null;
};

/**
 * Checks the integrity of the document by recursively comparing the elements of the PathTree to
 * that of the DOM node.
 * @return {Array of results}
 */
PathTree.prototype.check = function() {
	if (this.DOMNode.__pathNodes.length &gt; 1) {
		console.log(this.DOMNode, this.DOMNode.__pathNodes);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'Node has multiple paths';
	}

	var domNodePathNode = this.DOMNode.__pathNodes[0];
	if (domNodePathNode.id !== this.id) {
		console.log(this.DOMNode, this);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'No id match';
	}

	var definedChildNodesInDom = (function() {
		var ref, ref1;
		ref = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes
			: (this.DOMNode.content &amp;&amp; this.DOMNode.content.childNodes) || [];
		var results = [];
		for (var j = 0, len = ref.length; j &lt; len; j++) {
			var childNode = ref[j];
			if (((ref1 = childNode.__pathNodes) != null ? ref1.length : void 0) &gt; 0) {
				results.push(childNode);
			}
		}
		return results;
	}.bind(this))();

	if (definedChildNodesInDom.length !== this.children.length) {
		console.log(definedChildNodesInDom, this.children, this);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'Different amount of children';
	}

	var childNodes = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes
		: (this.DOMNode.content &amp;&amp; this.DOMNode.content.childNodes) || [];
	childNodes = Array.from(childNodes).filter(function(childNode) {
		return !childNode.tagName || childNode.tagName.toLowerCase() !== 'transient'
			|| coreUtils.elementIsTemplateDescendant(childNode);
	});
	if (definedChildNodesInDom.length !== childNodes.length) {
		console.log(definedChildNodesInDom, childNodes);
		console.warn('Warning: Found zombie nodes in DOM.');
	}

	var results = [];
	for (var i = 0, j = 0, len = definedChildNodesInDom.length; j &lt; len; i = ++j) {
		results.push(this.children[i].check());
	}

	return results;
};

/**
 * Returns the last added pathNode of an element. If a parent DOM element is provided, we search
 * for the pathNode that matches on parent.
 * @param  {DOMNode} elem       Element to get pathNode of.
 * @param  {DOMNode} parentElem Parent of Element (optional).
 * @return {PathTree}           PathNode found or null.
 */
PathTree.getPathNode = function(elem, parentElem) {
	if (!elem || !elem.__pathNodes) {
		return null;
	}

	if (!parentElem || !parentElem.__pathNodes) {
		return elem.__pathNodes[elem.__pathNodes.length - 1];
	}

	var matchingElement = null;
	parentElem.__pathNodes.some(function(parentPathNode) {
		return (matchingElement = elem.__pathNodes.find(function(pathNode) {
			return pathNode.parent.id === parentPathNode.id;
		}));
	});

	return matchingElement;
};

var jsonml = {
	TAG_NAME_INDEX: 0,
	ATTRIBUTE_INDEX: 1,
	ELEMENT_LIST_OFFSET: 2
};


/**
 * Returns the DOM element at the end of the path.
 * @param  {HTMLElement|PathTree} parentElement The element used to nagivate to the path from. May
 *                                              be either a DOM element or a PathTree.
 * @param  {JsonMLPath} path                    Path to follow on parentElement.
 * @return {[DOMElement, int, DOMElement, int]} The DOM element found, including its index on its
 *                                              parent, the parent DOM element, as possibly a
 *                                              JsonML index in case the path doesn't at a DOM
 *                                              element (it may end at a tag name or attribute
 *                                              object).
 */
PathTree.elementAtPath = function(parentElement, path) {
    // debugger;
	var parentPathNode = parentElement instanceof PathTree ? parentElement
		: PathTree.getPathNode(parentElement);

	var jsonmlIndex = path[0];
	if (jsonmlIndex === jsonml.ATTRIBUTE_INDEX) {
		// An attribute's parent could arguably be the element it's defined on, so the childElement
		// and parentElement are the same. Therefore, there also can't be a childIndex.
		return [parentElement, undefined, parentElement, jsonmlIndex];
	}

	var childIndex = jsonmlIndex - jsonml.ELEMENT_LIST_OFFSET;
	var childPathNode = parentPathNode &amp;&amp; parentPathNode.children[childIndex];

	var nextJsonmlIndex = path[1];
	if (path.length === 1
		|| nextJsonmlIndex === jsonml.TAG_NAME_INDEX
		|| nextJsonmlIndex === jsonml.ATTRIBUTE_INDEX) {
		var childElement = childPathNode &amp;&amp; childPathNode.DOMNode;
		parentElement = parentPathNode.DOMNode;
		return [childElement, childIndex, parentElement, nextJsonmlIndex];
	}
	return PathTree.elementAtPath(childPathNode, path.slice(1));
};

// ////////////////////////////////////////////////////
// // INFO: coreMutation

// const coreUtils = coreUtilsModule;
var coreEvents = coreEventsModule;
const coreMutation = {};

coreEvents.createEvent('mutation');

const observerOptions = {
	childList: true,
	subtree: true,
	attributes: true,
	characterData: true,
	attributeOldValue: true,
	characterDataOldValue: true
};

let rootElement;
const primaryObserver = new MutationObserver(mutationsHandler);
const fragmentObservers = {};
const fragmentParentMap = {};

coreMutation.emitMutationsFrom = (_rootElement) =&gt; {
	rootElement = _rootElement;
	// Add MutationObserver on root.
	primaryObserver.observe(rootElement, observerOptions);
	// Add MutationObservers on to all documentFragments (the things that live inside &lt;template&gt;s).
	coreUtils.recursiveForEach(rootElement, (node) =&gt; {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			setupFragmentObserver(node.content, node);
		}
	});
	isPaused = false;
};

function mutationsHandler(mutations) {
	mutations.forEach(function forEachMutation(mutation) {
		// DocumentFragments (as per the specification) can't have parents, even if they actually do.
		// Therefore, they also can't exist in the PathTree. Instead, we pretend that they *are*
		// their parents. Since this is only used with &lt;template&gt;s, whose only children are a single
		// documentFragment, this makes sense. The JsonML also does not store the documentFragment,
		// but it is automatically created when creating a &lt;template&gt; tag.
		if (mutation.target.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			// We use defineProperty rather than a primitive assignemtn, because the target property is
			// read-only.
			Object.defineProperty(mutation, 'target', {
				value: fragmentParentMap[mutation.target.id]
			});
		}

		coreEvents.triggerEvent('mutation', mutation);
	});
}

/**
 * Set ups a Mutation Observer on a Document Fragment.
 * @param {DocumentFragment} fragment Fragment to observe.
 * @param {DOMElement} element        Element containing fragment.
 * @private
 */
function setupFragmentObserver(fragment, element) {
	if (fragment.id) {
		return;
	}
	fragment.id = coreUtils.randomString();
	const fragmentObserver = new MutationObserver(mutationsHandler);
	fragmentObserver.observe(fragment, observerOptions);
	fragmentObservers[fragment.id] = [fragment, fragmentObserver];
	fragmentParentMap[fragment.id] = element;
}

/**
 * Removes a Mutation Observer from a Document Fragment.
 * @param {DocumentFragment} fragment Fragment to remove observer from.
 * @private
 */
function teardownFragmentObserver(fragment) {
	if (!fragment.id || !fragmentParentMap[fragment.id]) {
		return;
	}
	let fragmentObserver;
	[fragment, fragmentObserver] = fragmentObservers[fragment.id];
	fragmentObserver.disconnect();
	delete fragmentObservers[fragment.id];
	delete fragmentParentMap[fragment.id];
}

// The global mutation observer does not observe on changes to documentFragments (the things that
// live inside &lt;template&gt;s within the document, so we have to manually create and manage individual
// observers for each documentFragment.
// Before we can do that, we have to create DOMNodeInserted and DOMNodeDeletedoutselves ourselves,
// because this module gets loaded before they get created (by coreOpApplier or coreOpCreator).
// The 'idempotent' option allows these events to be created even if they already. Just to be safe.
coreEvents.createEvent('DOMNodeInserted', { idempotent: true });
coreEvents.createEvent('DOMNodeDeleted', { idempotent: true });

// Whenever the DOM gets modified, we add/remove potential MutationObservers from documentFragments
// // (i.e. the things living inside &lt;template&gt;s).
coreEvents.addEventListener('DOMNodeInserted', addedNode =&gt; {
	coreUtils.recursiveForEach(addedNode, (node) =&gt; {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			setupFragmentObserver(node.content, node);
		}
	});
}, coreEvents.PRIORITY.IMMEDIATE);

coreEvents.addEventListener('DOMNodeDeleted', removedNode =&gt; {
	coreUtils.recursiveForEach(removedNode, function(node) {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			teardownFragmentObserver(node.content);
		}
	});
}, coreEvents.PRIORITY.IMMEDIATE);

// // To not create a live-lock, the coreOpApplier module needs to pause the mutation observer when
// // adding incoming ops to the DOM. Otherwise, those incoming ops would in turn create new ops, and
// // so on.
// // The following allows other modules to manage the MutationObservers.
let isPaused = true;
Object.defineProperty(coreMutation, 'isPaused', {
	get: () =&gt; isPaused
});


coreMutation.pause = () =&gt; {
	if (isPaused) return;
	Object.keys(fragmentObservers).forEach(function(fragmentId) {
		var [_fragment, fragmentObserver] = fragmentObservers[fragmentId];
		fragmentObserver.disconnect();
	});
	primaryObserver.disconnect();
	isPaused = true;
};

coreMutation.resume = () =&gt; {
	if (!isPaused) return;
	Object.keys(fragmentObservers).forEach(function(fragmentId) {
		var [fragment, fragmentObserver] = fragmentObservers[fragmentId];
		fragmentObserver.observe(fragment, observerOptions);
	});
	primaryObserver.observe(rootElement, observerOptions);
	isPaused = false;
};

// ////////////////////////////////////////////////

// coreDOM

// JavaScript code here
// 'use strict';
/**
 * This modules allows other modules a more convenient way of overriding certain document
 * properties, specifically by preventing accidental infinite recursive calls and scope-binding
 * issues. On top of that, it allows modules  to override certain properties only internally, i.e.
 * so other modules will use some overriden property (e.g. document.createElement), while code
 * written in userland still will use the "regular" document.createElement.
 *
 * This module was particularly written to be used with protected mode, so elements created by
 * other modules automatically will be pre-approved while elements created in userland will not.
 */

// Directives to ESLint, so it'll allow us to use documentProxyObj and _document, which appears to
// be undefined, as they rather unorthodoxly is defined in wrapper-header.js. Also prevent ESLint
// from complaining that documentProxyObj is never used.
/* global _document documentProxyObj */
/* exported documentProxyObj */

const coreDOMModule = {};

// This object should be passed in as the last parameter by all other modules to Element
// prototype methods, so all modules can detect when a call to one of these comes from another
// module rather than from userland. It would be better to override the Element object like we
// override the document object, but it seems to be impossible to do this meaningfully.
coreDOMModule.elementOptions = {};

coreDOMModule.internalDocument = document;
// coreDOMModule.externalDocument = _document;
coreDOMModule.externalDocument = documentProxyObj;

const contexts = {
	INTERNAL: 0,
	BOTH: 1
};

coreDOMModule.CONTEXT = new Proxy(contexts, {
	get: (target, name) =&gt; {
		if (name in target) return target[name];
		throw new Error(`Invalid context ${name}, must be INTERNAL or BOTH`);
	}
});

const internalDocumentOverrides = new Map();


/**
 * Override a property on the document object, either internally or internally and externally.
 * @param  {string} property Name of property to override on document.
 * @param  {enum} context    Context, either CONTEXT.INTERNAL or CONTEXT.BOTH.
 * @param  {any} value       Any value.
 * @public
 */
coreDOMModule.overrideDocument = (property, context, value) =&gt; {
	// If the user is trying to override a property on the internal document, we save the property to
	// a map, so we can find it when it's being requested on the proxy document. If we did a
	// 'primitive' override on the document object, the override would also be active
	if (context === coreDOMModule.CONTEXT.INTERNAL) {
		if (internalDocumentOverrides.has(property))
			throw new Error('Property has already been overriden');

		return internalDocumentOverrides.set(property, value);
	}

	if (context === coreDOMModule.CONTEXT.BOTH) {
		if (typeof value === 'function') {
			// If the requested value is a function, bind the document's context to it and bind the
			// original function as the first argument. This, for instance, allows somebody to override
			// document.createElement and still have access to the original createElement function from
			// within the new implementation.
			const originalProperty = coreDOMModule.externalDocument[property]
				.bind(coreDOMModule.externalDocument);
			coreDOMModule.externalDocument[property] = value.bind(coreDOMModule.externalDocument,
				originalProperty);
		} else {
			coreDOMModule.externalDocument[property] = value;
		}
		return;
	}

	throw new Error('Invalid context', context);
};

///// INFO: this leads to the absence of persistence for
///// the new sections

// /**
//  * Proxy object for document. The proxy is actually defined in wrapper-header.js using an empty
//  * object (documentProxyObj), which we now override with our own get trap.
//  * @param  {Object} obj  Object the property is to be accessed on. Will always be document.
//  * @param  {string} prop Name of property.
//  * @return {mixed}       The property's value. Can be anything.
//  */
// documentProxyObj.get = (obj, prop) =&gt; {
// 	if (prop === 'PROXY_DOCUMENT') return true;

// 	if (internalDocumentOverrides.has(prop)) {
// 		// If the requested value is a function, bind the document's context to it and bind the
// 		// original function as the first argument. This, for instance, allows somebody to override
// 		// document.createElement and still have access to the original createElement function from
// 		// within the new implementation.
// 		return typeof internalDocumentOverrides.get(prop) === 'function'
// 			? internalDocumentOverrides.get(prop).bind(obj, coreDOMModule.externalDocument[prop])
// 			: internalDocumentOverrides.get(prop);
// 	}

// 	// If the requested value is a function, bind the document's context to it.
// 	return typeof obj[prop] === 'function'
// 		? obj[prop].bind(obj)
// 		: obj[prop];
// };

///// INFO: this leads to the absence of persistence for
///// the new sections


// /////////////////////////////////////////////////////////////////////////////

// // INFO: coreJsonML

// JavaScript code here
// 'use strict';
/* JsonML &lt;-&gt; HTML library by Kristian B. Antonsen
 * This library is based on jQuery JSONML Plugin by Trevor Norris.
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 */
// const coreUtils = require('./coreUtils');
// const coreDOM = require('./coreDOM');
// const coreUtils = coreUtilsModule;


const coreDOM = coreDOMModule;
const coreJsonML = {};

function isPlainObject(obj) {
	return obj &amp;&amp; typeof obj === 'object'
	// Previously, we did comparison like: Object.getPrototypeOf(obj) === Object.prototype, but we
	// can no longer do that, because if we use the parent's ShareDB Connection, plain objects created
	// in the outer frame will have used that frame's Object.prototype, which is not the same as the
	// Object.prototype in the inner frame, even though they're identical. Basically:
	// window.Object !== iframe.contentWindow.Object.
	&amp;&amp; Object.prototype.toString.call(obj) === '[object Object]';
}

function toHTML(elem, xmlNs, scripts) {
	const fragment = document.createDocumentFragment();
	let i = 0;
	let name = null;
	let selector;

	// Check if is an element or array of elements
	if (typeof elem[0] == 'string') {
		name = elem[0];
		i = 1;
	}

	if (elem[0] === '!' || elem[0] === '#comment') {
		return document.createComment(elem.slice(typeof elem[1] === 'string' ? 1 : 2).join(''));
	}

	for (; i &lt; elem.length; i++) {
		// If array create new element
		if (Array.isArray(elem[i])) {
			// children of foreignobject element should use the default XHTML namespace
			// ('http://www.w3.org/1999/xhtml'), so we set it to undefined. Curiously enough, if we
			// actually do `xmlNs = "http://www.w3.org/1999/xhtml"`, stuff won't be rendered properly.
			if (name.toLowerCase() === 'foreignobject') {
				xmlNs = undefined;
			}

			fragment.appendChild(toHTML(elem[i], xmlNs, scripts));

			// If object set element attributes
		} else if (isPlainObject(elem[i])) {
			if (name) {

				name = coreUtils.sanitizeString(name);

				// When loading a website with an SVG element without a namespace attribute, Chrome will
				// guess the namespace itself. When adding it like we do with Webstrates, it won't. So
				// to have Webstrates give us a more normal browser experience, we add the namespace
				// manually.
				if (name.toLowerCase() === 'svg') {
					xmlNs = 'http://www.w3.org/2000/svg';
				}

				// As also mentioned in regards to foreignobject, setting the namspace to the default
				// ("http://www.w3.org/1999/xhtml") causes stuff to not render properly.
				if (xmlNs &amp;&amp; xmlNs !== 'http://www.w3.org/1999/xhtml') {
					selector = document.createElementNS(xmlNs, name);
				} else {
					selector = document.createElement(name);
				}

				// Add attributes to the element.
				for (let index in elem[i]) {
					// The __wid attribute is a unique ID assigned each node and should not be in the DOM, but
					// instead be a property on the DOM element.
					if (index.toLowerCase() === '__wid') {
						coreUtils.setWidOnElement(selector, elem[i][index]);
						continue;
					}
					const value = coreUtils.unescape(elem[i][index]);
					index = coreUtils.sanitizeString(index);
					if (xmlNs === 'http://www.w3.org/2000/svg') {
						if (index === 'href' || index === 'xlink:href') {
							selector.setAttributeNS('http://www.w3.org/1999/xlink', index, value,
								coreDOM.elementOptions);
						}
					}
					const isSvgPath = selector.tagName.toLowerCase() === 'path' &amp;&amp; index === 'd';
					if (isSvgPath) {
						selector.__d = value;
					}
					selector.setAttribute(coreUtils.unescapeDots(index), value, coreDOM.elementOptions);
				}

				// Add scripts to our scripts list, so we can execute them later synchronously.
				if (selector.tagName.toLowerCase() === 'script') {
					selector.async = false;
					scripts &amp;&amp; scripts.push(selector);
				}
			}

			// If string or number insert text node
		} else if (typeof elem[i] == 'number' || typeof elem[i] == 'string') {
			fragment.appendChild(document.createTextNode(elem[i]));

			// If is an element append to fragment
		} else if (elem[i].nodeType) {
			fragment.appendChild(elem[i]);
		}
	}

	if (!selector &amp;&amp; name) {
		name = coreUtils.sanitizeString(name);
		selector = document.createElement(name);
	}

	// If a selector is set append children and return
	if (selector) {
		// When creating &lt;templates&gt;, we need the document to actually contain an documentFragment.
		// If we just add a documentFragment to an element, the children of documentFragment will
		// actually be added instead. To prevent this, we add the children to the `content` property
		// if it exists.
		if (selector.content &amp;&amp; selector.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			selector.content.appendChild(fragment);
		} else {
			selector.appendChild(fragment);
		}
		return selector;
	}

	// Otherwise return children of fragment
	return fragment.childNodes;
}

coreJsonML.toHTML = toHTML;

function addChildren(/*DOM*/ elem, /*function*/ filter, /*JsonML*/ jml) {
	const childNodes = coreUtils.getChildNodes(elem);
	if (childNodes.length === 0) return false;

	for (let i=0; i&lt;childNodes.length; i++) {
		const child = fromHTML(childNodes[i], filter);
		if (child) {
			jml.push(child);
		}
	}

	return true;
}

/**
 * @param {Node} elem
 * @param {function} filter
 * @return {array} JsonML
 */
function fromHTML(elem, filter) {
	// If an element doesn't have a PathTree, we don't want it in the JsonML. This will be the case
	// for &lt;transient&gt; elements.
	if (!elem || !elem.nodeType || !elem.__pathNodes || elem.__pathNodes.length === 0) {
		// free references
		return (elem = null);
	}

	let i, jml;
	switch (elem.nodeType) {
		case document.ELEMENT_NODE:
		case document.DOCUMENT_NODE:
		case document.DOCUMENT_FRAGMENT_NODE: {
			jml = [elem.tagName||''];

			const attr = elem.attributes;
			let props = {};
			let hasAttrib = false;

			for (i=0; attr &amp;&amp; i&lt;attr.length; i++) {
				// Transient attributes should not be added to the JsonML.
				if (config.isTransientAttribute(elem, attr[i].name)) {
					continue;
				}
				if (attr[i].specified) {
					if (attr[i].name === 'style') {
						props.style = elem.style.cssText || attr[i].value;
					} else if ('string' === typeof attr[i].value) {
						if (elem.namespaceURI === 'http://www.w3.org/2000/svg') {
							props[attr[i].name.toLowerCase()] = attr[i].value;
						} else {
							props[attr[i].name] = attr[i].value;
						}
					}
					hasAttrib = true;
				}
			}

			if (elem.__wid) {
				props.__wid = elem.__wid;
				hasAttrib = true;
			}

			jml.push(props); //Webstrates always assumes that an element has attributes.

			let child, childNodes;
			switch (jml[0].toLowerCase()) {
				case 'frame':
				case 'iframe':
					break; //Do not recursively serialize content in iFrames (CNK)
				case 'style':
					child = elem.styleSheet &amp;&amp; elem.styleSheet.cssText;
					if (child &amp;&amp; 'string' === typeof child) {
						// unwrap comment blocks
						child = child.replace('&lt;!--', '').replace('--&gt;', '');
						jml.push(child);
					} else if ((childNodes = coreUtils.getChildNodes(elem))) {
						for (i=0; i&lt;childNodes.length; i++) {
							child = childNodes[i];
							child = fromHTML(child, filter);
							if (child &amp;&amp; 'string' === typeof child) {
								// unwrap comment blocks
								child = child.replace('&lt;!--', '').replace('--&gt;', '');
								jml.push(child);
							}
						}
					}
					break;
				case 'input':
					addChildren(elem, filter, jml);
					child = (elem.type !== 'password') &amp;&amp; elem.value;
					if (child) {
						if (!hasAttrib) {
							// need to add an attribute object
							jml.shift();
							props = {};
							jml.unshift(props);
							jml.unshift(elem.tagName||'');
						}
						props.value = child;
					}
					break;
				case 'textarea':
					if (!addChildren(elem, filter, jml)) {
						child = elem.value || elem.innerHTML;
						if (child &amp;&amp; 'string' === typeof child) {
							jml.push(child);
						}
					}
					break;
				default:
					addChildren(elem, filter, jml);
					break;
			}

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}

			// free references
			elem = null;
			return jml;
		}
		case Node.TEXT_NODE: // text node
		case Node.CDATA_SECTION_NODE: { // CDATA node
			const str = String(elem.nodeValue);
			// free references
			elem = null;
			return str;
		}
		case Node.DOCUMENT_TYPE_NODE: { // doctype
			jml = ['!'];

			const type = ['DOCTYPE', (elem.name || 'html').toLowerCase()];

			if (elem.publicId) {
				type.push('PUBLIC', '"' + elem.publicId + '"');
			}

			if (elem.systemId) {
				type.push('"' + elem.systemId + '"');
			}

			jml.push(type.join(' '));

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}
			// free references
			elem = null;
			return jml;
		}
		case Node.COMMENT_NODE: { // comment node
			if ((elem.nodeValue||'').indexOf('DOCTYPE') !== -1) {
			// free references
				elem = null;
				return null;
			}

			jml = ['!',
				elem.nodeValue];

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}

			// free references
			elem = null;
			return jml;
		}
		default: { // etc.
			// free references
			return (elem = null);
		}
	}
}

coreJsonML.fromHTML = fromHTML;

// module.exports = coreJsonML;
// INFO: coreOpApplier

/*
Webstrates ApplyOp (coreOpApplier.js)

This module exposes the applyOp(op, rootElement) function on the Webstrates scope. This function
applies a subset of json0 OT operations (see https://github.com/ottypes/json0) to a DOM element.
The operations handled are list insertion and deletion (li and ld), as well as string insertion and
deletion (si and sd). These operations are generated on another client using the CreateOp module.
*/
// const coreEvents = require('./coreEvents');
// const coreUtils = require('./coreUtils');
// const corePathTree = require('./corePathTree');
// const coreMutation = require('./coreMutation');
// const coreJsonML = require('./coreJsonML');
// const coreDOM = require('./coreDOM');

// const coreEvents = coreEventsModule;
// const coreUtils = coreUtilsModule;
// const coreDOM = coreDOMModule;

// const jsonml = {
// 	TAG_NAME_INDEX: 0,
// 	ATTRIBUTE_INDEX: 1,
// 	ELEMENT_LIST_OFFSET: 2
// };

const corePathTree = PathTree;
// const coreMutation = coreMutation;
const coreJsonMLModule = coreJsonML;



const coreOpApplier = {};

// The 'idempotent' option allows these events to be created even if they already
// exists. We do this, because these events also are used (and created) in coreOpCreator.
coreEvents.createEvent('DOMAttributeSet', { idempotent: true });
coreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });
coreEvents.createEvent('DOMNodeInserted', { idempotent: true });
coreEvents.createEvent('DOMNodeDeleted', { idempotent: true });
coreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });
coreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });
coreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });
coreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });



/**
 * Extract the XML namespace from a DOM element.
 * @param  {DOMNode} element Element.
 * @return {string}          Namespace string.
 * @private
 */
function getNamespace(element) {
	if (!element || !element.getAttribute) {
		return undefined;
	}

	if (element.closest('foreignObject') &amp;&amp; !(element instanceof SVGForeignObjectElement)) {
		return document.body.namespaceURI;
	}

	return element.getAttribute('xmlns') ? element.getAttribute('xmlns') : element.namespaceURI;
}

/**
 * Recursively navigates an element using path to set the value as an attribute.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode. Last element of path is the attribute
 *                                key.
 * @param {string} value          Attribute value.
 * @private
 */
function setAttribute(rootElement, path, cleanAttributeName, newValue) {
	const [childElement] = corePathTree.elementAtPath(rootElement, path);

	// This has been commented out as it makes non-transient attributes appear transient in protected
	// mode, and we don't really seem to need it. If an op comes in, it can't really be transient
	// after all.
	//if (config.isTransientAttribute(childElement, cleanAttributeName)) {
	//	return;
	//}

	// The __wid attribute is a unique ID assigned each node and should not be in the DOM.
	if (cleanAttributeName === '__wid') {
		coreUtils.setWidOnElement(childElement, newValue);
		return;
	}

	// MongoDB doesn't support periods (.) inkeys, so we store them as &amp;dot; instead.
	const attributeName = coreUtils.unescapeDots(cleanAttributeName);
	newValue = coreUtils.unescape(newValue);

	const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
	if (isSvgPath) childElement.__d = newValue;

	const oldValue = childElement.getAttribute(attributeName);
	childElement.setAttribute(attributeName, newValue, coreDOM.elementOptions);

	// Last argument is false for not local, i.e happened on another client.
	coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
		false);
}

/**
 * Recursively navigates an element using path to remove the attribute at the end of the path.
 * @param {DOMNode} rootElement   DOMNode usf ed as root element for path navigation.
 * @param {DOMPath} path          Path to fllow on DOMNode. Last element of path is the attribute
 *                                key.
 * @private
 */
function removeAttribute(rootElement, path, attributeName) {
	const [childElement ] = corePathTree.elementAtPath(rootElement, path);

	if (config.isTransientAttribute(childElement, attributeName)) {
		return;
	}

	const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
	if (isSvgPath) delete childElement.__d;
	const oldValue = childElement.getAttribute(attributeName);
	childElement.removeAttribute(attributeName);

	// Last argument is false for not local, i.e happened on another client.
	coreEvents.triggerEvent('DOMAttributeRemoved', childElement, attributeName, oldValue, false);
}

/**
 * Recursively navigates an element using path to insert an element.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {mixed} value           Element to insert, either a text string or JSON element.
 * @private
 */
function insertNode(rootElement, path, value) {
	const [childElement, childIndex, parentElement] =
		corePathTree.elementAtPath(rootElement, path);

	const namespace = getNamespace(parentElement);
	const newElement = typeof value === 'string' ?
		document.createTextNode(value) : coreJsonML.toHTML(value, namespace);

	// childElement may be undefined, and if so we insert newElement at the end of the list. If
	// chidElement is defined, however, we insert the element before childElement.
	coreUtils.appendChildWithoutScriptExecution(parentElement, newElement, childElement);

	const parentPathNode = corePathTree.getPathNode(parentElement);
	const childPathNode = corePathTree.create(newElement, parentPathNode);

	// childPathNode may not have been created, because its parent doesn't have a PathTree (because
	// its a descendant of a transient element, or a transient element itself) or because the new
	// element itself is a transient element.
	if (childPathNode) {
		// Insert new element into parent PathTree.
		parentPathNode.children.splice(childIndex, 0, childPathNode);
	}

	coreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);
}

/**
 * Recursively navigates an element using path to delete an element.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @private
 */
function deleteNode(rootElement, path) {
	const [childElement, childIndex, parentElement] =
		corePathTree.elementAtPath(rootElement, path);

	// This part is a bit of a hack, because contenteditable is a weird beast to play with.
	// Consider a contenteditable field with the text HELLO in it. Say user A puts a cursor before
	// the letter O: HELL|O. User B then makes a linebreak after the H. Now, ELLO gets removed,
	// setting user A's cursor after the H|, and then the ELLO part gets reinserted in a DIV element
	// below. Now the cursor is after H: H|, and not before the O as before: ELL|O.
	// To fix this issue, when something gets deleted, we try to find the next close text node, see
	// if its contents matches what we just removed, and if so, we set our cursor there, because it's
	// likely that this deletion was caused by the scenario just described.
	const fakeRange = getSelectionRange(childElement);
	let nextTextNode;
	// A text node directly after us.
	if (childElement.nextSibling &amp;&amp; childElement.nextSibling.nodeType === document.TEXT_NODE) {
		nextTextNode = childElement.nextSibling;
	// A text node in an element right after us.
	} else if (childElement.nextElementSibling &amp;&amp; childElement.nextElementSibling.firstChild
		&amp;&amp; childElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {
		nextTextNode = childElement.nextElementSibling.firstChild;
	// A text node right after our parent (if we're in a DIV for instance).
	} else if (parentElement.nextSibling
		&amp;&amp; parentElement.nextSibling.nodeType === document.TEXT_NODE) {
		nextTextNode = parentElement.nextSibling;
	// A text node in a DIV right after our parent (if we're in a DIV for instance).
	} else if (parentElement.nextElementSibling &amp;&amp; parentElement.nextElementSibling.firstChild
		&amp;&amp; parentElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {
		nextTextNode = parentElement.nextElementSibling.firstChild;
	}

	if (fakeRange &amp;&amp; childElement.data &amp;&amp; nextTextNode &amp;&amp; nextTextNode.data === childElement.data) {
		if (fakeRange.startContainer === childElement) {
			fakeRange.startContainer = nextTextNode;
		}
		if (fakeRange.endContainer === childElement) {
			fakeRange.endContainer = nextTextNode;
		}
		setSelectionRange(nextTextNode, fakeRange);
	}

	// Update PathTree to reflect the deletion.
	// TODO: Use PathTree.remove() instead.
	const parentPathNode = corePathTree.getPathNode(parentElement);
	//const childPathNode = corePathTree.getPathNode(childElement, parentPathNode);
	parentPathNode.children.splice(childIndex, 1);

	// And remove the actual DOM node.
	childElement.remove();

	// Notify nodeRemoved listeners.
	coreEvents.triggerEvent('DOMNodeDeleted', childElement, parentElement, false);
}

/**
 * Replace a node, either a tag name, list of attributes or a regular node.
 * Note that this is added for compatibility with a wider array of json0 operations such as those
 * used by Webstrates file system. Webstrates itself does not create these kinds of operations.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {mixed} value           Element to insert, new tag name, or new set of attributes.
 * @private
 */
function replaceNode(rootElement, path, value) {
	const [childElement, childIndex, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);

	// Webstrates file system has some broken parsing, so it may think JavaScript like "&lt; b)" in
	// "if (a &lt; b)" is an element and try to send a replacement op. In this case, childElement
	// doesn't exist. This should be solved in Webstrates file system, but we'll fix it here, too.
	if (!childElement) {
		return;
	}

	switch (indexType) {
	// We're renaming a tag, e.g. when &lt;span&gt;foo&lt;/span&gt; should become &lt;div&gt;foo&lt;/div&gt;.
		case jsonml.TAG_NAME_INDEX: {
			const oldElement = childElement;
			const namespace = getNamespace(oldElement);
			const newElement = coreJsonML.toHTML([value], namespace);

			const parentPathNode = corePathTree.getPathNode(parentElement);
			if (!parentPathNode) {
				console.warn('No parentPathNode found, aborting. This shouldn\'t happen, but...');
				return;
			}
			// Move all children.
			while (oldElement.firstChild) {
				coreUtils.appendChildWithoutScriptExecution(newElement, oldElement.firstChild);
			}

			// Copy all attributes.
			for (let i = 0; i &lt; oldElement.attributes.length; i++) {
				const attr = oldElement.attributes.item(i);
				const attributeName = attr.nodeName;
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				if (isSvgPath) newElement.__d = attr.nodeValue;
				newElement.setAttribute(attributeName, attr.nodeValue);
			}

			// Overwrite old node with new node.
			coreUtils.appendChildWithoutScriptExecution(parentElement, newElement, oldElement);
			oldElement.remove();

			const newElementPathNode = corePathTree.create(newElement, parentPathNode, true);

			// New element may not have a PathNode if it's a transient object.
			if (!newElementPathNode) {
				break;
			}

			parentPathNode.children.splice(childIndex, 1, newElementPathNode);

			coreEvents.triggerEvent('DOMNodeDeleted', oldElement, parentElement, false);
			coreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);
			break;
		}
		// We're replacing an entire object of attributes by writing all the new attributes and
		// deleting old ones.
		case jsonml.ATTRIBUTE_INDEX: {
			const newAttributes = value;
			const oldAttributeKeys = Array.from(childElement.attributes).map(function(attribute) {
				return attribute.name;
			});

			const attributes = new Set([...Object.keys(newAttributes), ...oldAttributeKeys]);
			attributes.forEach(function(attributeName) {
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				if (attributeName in newAttributes) {
					if (isSvgPath) childElement.__d = newAttributes[attributeName];
					childElement.setAttribute(attributeName, newAttributes[attributeName]);
				} else {
					if (isSvgPath) delete childElement.__d;
					childElement.removeAttribute(attributeName);
				}
			});
			break;
		}
		// Otherwise, we're just replacing a regular node.
		default: {
			deleteNode(rootElement, path);
			insertNode(rootElement, path, value);
			break;
		}
	}
}

/**
 * Get element with cursor/selection offset. Given a negative offset, traverse through the DOM
 * tree to find the appropriate element.
 * @param  {DOMNode} element    Element to traverse from
 * @param  {Number} offset      Cursor/selection offset.
 * @return {[element, offset]}  Touple containing new element and (positive) offset.
 * @private
 */
function findOffsetElement(element, offset) {
	// If the offset is within this element, we can return.
	if (offset &gt;= 0) return [ element, offset ];

	// Explore the previous sibling's children if has children.
	if (element.lastChild) {
		offset = element.lastChild.nodeType === document.TEXT_NODE
			? offset + element.lastChild.length : offset;
		return findOffsetElement(element.lastChild, offset);
	}

	if (!element.previousSibling) {
		// If he element isn't a text node and has no children, we move up the tree to explore the
		// parent node.
		offset = element.parentNode.nodeType === document.TEXT_NODE
			? offset + element.parentNode.length : offset;
		return findOffsetElement(element.parentNode, offset);
	}

	// Explore the previous sibling if it's a text node. This recursion will converge towards a
	// positive offset.
	if (element.previousSibling.nodeType === document.TEXT_NODE) {
		return findOffsetElement(element.previousSibling,
			offset + element.previousSibling.nodeValue.length);
	}
}

/**
 * Find selection range in node if it exists.
 * @param  {TextNode} textNode TextNode to look for Range in.
 * @return {mixed}             Basic object containing the essential properties of a Range object.
 * @private
 */
function getSelectionRange(textNode) {
	// If there are no selections, return.
	if (window.getSelection().rangeCount === 0) {
		return;
	}

	var realRange = window.getSelection().getRangeAt(0);
	// If selection isn't in this node, return.
	if (realRange.commonAncestorContainer !== textNode) {
		return;
	}

	// Finally, return the range. We can't return the original range, as it may change. Since the
	// range is already bound to the DOM, if we clone it, the cloned range will also be bound to the
	// DOM. If any changes are made to the involved TextNode, then the offsets will therefore be
	// set to 0. Therefore, we mange a basic object containing the essential properties of a real
	// Range object.
	var fakeRange = {
		startOffset: realRange.startOffset,
		startContainer: realRange.startContainer,
		endOffset: realRange.endOffset,
		endContainer: realRange.endContainer
	};
	return fakeRange;
}

/**
 * Set selection on textnode based on fakeRange. Uses findOffsetElement to fix negative offsets.
 * @param {TextNode} textNode  TextNode to base selection around.
 * @param {mixed} fakeRange    Basic object containing the essential properties of a Range object.
 * @private
 */
function setSelectionRange(textNode, fakeRange) {
	var realRange = document.createRange();

	if (fakeRange.startOffset &lt; 0) {
		var [startContainer, startOffset] = findOffsetElement(fakeRange.startContainer,
			fakeRange.startOffset);
		fakeRange.startContainer = startContainer;
		fakeRange.startOffset = startOffset;
	}

	if (fakeRange.endOffset &lt; 0) {
		var [endContainer, endOffset] = findOffsetElement(fakeRange.endContainer,
			fakeRange.endOffset);
		fakeRange.endContainer = endContainer;
		fakeRange.endOffset = endOffset;
	}

	realRange.setStart(fakeRange.startContainer, fakeRange.startOffset);
	realRange.setEnd(fakeRange.endContainer, fakeRange.endOffset);
	window.getSelection().removeAllRanges();
	window.getSelection().addRange(realRange);
}

/**
 * Recursively navigates an element using path to insert text at an index.
 * @param {DOMNode} parentElement DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {int} charIndex         Index in existing string to insert new string at.
 * @param {string} value          String to be inserted.
 * @private
 */
function insertInText(rootElement, path, charIndex, value) {
	let [childElement, /*childIndex*/, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);
	let attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;

	switch (indexType) {
		case jsonml.TAG_NAME_INDEX:
			// Diff changes to tag names is not supported.
			throw Error('Unsupported indexType jsonml.TAGNAME_INDEX (0)');
		case jsonml.ATTRIBUTE_INDEX:
			// This is not necessarily an attribute change, because the attribute object in JsonML is
			// optional. Therefore, it may just be a change made to a comment or regular text node
			// without an attribute object. We verify by seeing if an attribute name exists.
			if (attributeName) {
				// Attribute value diff.
				attributeName = path.pop();
				// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,
				// which messes up our attribute diffing. We also do this in deleteInText below.
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				let oldValue = childElement.getAttribute(attributeName);
				if (isSvgPath) oldValue = childElement.__d;
				const newValue = oldValue.substring(0, charIndex)
					+ value + oldValue.substring(charIndex);
				if (isSvgPath) childElement.__d = newValue;
				childElement.setAttribute(attributeName, newValue);
				coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
					false);
				coreEvents.triggerEvent('DOMAttributeTextInsertion', childElement, attributeName, charIndex,
					value, false);
				break;
			}
			// falls through if not an attribute value change.
		default:
			// Text node or comment content change.
	    var isComment = parentElement.nodeType === document.COMMENT_NODE;
	    parentElement = isComment ? parentElement : childElement;
	    var oldValue = parentElement.data;
            // var oldValue = parentElement.innerText;
	    var newValue = oldValue.substring(0, charIndex)
		+ value + oldValue.substring(charIndex);
	    // Generate current text selection range.
	    var fakeRange = getSelectionRange(parentElement);
	    parentElement.data = newValue;
            // parentElement.innerText = newValue;

			if (fakeRange) {
				// Adjust the range to account for the insertion.
				if (fakeRange.endContainer === parentElement &amp;&amp; fakeRange.endOffset &gt; charIndex) {
					fakeRange.endOffset += value.length;
					if (fakeRange.startContainer === parentElement &amp;&amp; fakeRange.startOffset &gt;= charIndex) {
						fakeRange.startOffset += value.length;
					}
				}
				// Update selection.
				setSelectionRange(parentElement, fakeRange);
			}

			coreEvents.triggerEvent('DOMTextNodeInsertion', childElement, parentElement, charIndex,
				value);
			break;
	}

	// Create and dispatch deprecated events.
	// TODO: This should be removed, eventually.
	var event = new CustomEvent('insertText', {
		detail: { position: charIndex, value: value, attributeName: attributeName }
	});
	parentElement.dispatchEvent(event);

}

/**
 * Recursively navigates an element using path to delete text at an index.
 * @param {DOMNode} parentElement DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {int} charIndex         Index in existing string to remove string from.
 * @param {string} value          String to be removed.
 * @private
 */
function deleteInText(rootElement, path, charIndex, value) {
	let [childElement, /*childIndex*/, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);
	let attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;

	switch (indexType) {
		case jsonml.TAG_NAME_INDEX:
			// Diff changes to tag names is not supported.
			throw Error('Unsupported indexType jsonml.TAGNAME_INDEX (1)');
		case jsonml.ATTRIBUTE_INDEX:
			if (attributeName) {
				// Attribute value diff.
				attributeName = path.pop();
				// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,
				// which messes up our attribute diffing. We also do this in insertInText above.
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				let oldValue = childElement.getAttribute(attributeName);
				if (isSvgPath) oldValue = childElement.__d;
				const newValue = oldValue.substring(0, charIndex)
					+ oldValue.substring(charIndex + value.length);
				if (isSvgPath) childElement.__d = newValue;
				childElement.setAttribute(attributeName, newValue);
				coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
					false);
				coreEvents.triggerEvent('DOMAttributeTextDeletion', childElement, attributeName, charIndex,
					value, false);
				break;
			}
			// If not an attribute value change: falls through.
		default:
			// Text node or comment content change.
			var isComment = parentElement.nodeType === document.COMMENT_NODE;
			parentElement = isComment ? parentElement : childElement;
			// Generate current text selection range.
			var fakeRange = getSelectionRange(parentElement);
	    var oldValue = parentElement.data;
            // var oldValue = parentElement.innerText;
			var newValue = oldValue.substring(0, charIndex)
				+ oldValue.substring(charIndex + value.length);
	    parentElement.data = newValue;
            // parentElement.innerText = newValue;

			if (fakeRange) {
				// Adjust the range to account for the deletion.
				if (fakeRange.endContainer === parentElement &amp;&amp; fakeRange.endOffset &gt; charIndex) {
					fakeRange.endOffset -= value.length;
					if (fakeRange.startContainer === parentElement &amp;&amp; fakeRange.startOffset &gt;= charIndex) {
						fakeRange.startOffset -= value.length;
					}
				}
				// Update selection.
				setSelectionRange(parentElement, fakeRange);
			}

			coreEvents.triggerEvent('DOMTextNodeDeletion', childElement, parentElement, charIndex, value);
			break;
	}

	// Create and dispatch deprecated events. This should be removed, eventually.
	const event = new CustomEvent('deleteText', {
		detail: { position: charIndex, value: value, attributeName: attributeName }
	});
	parentElement.dispatchEvent(event);

	// Notify deleteText listeners.
	//coreEvents.triggerEvent("deleteText", charIndex, value, attributeName);
}

/**
 * Apply an operation to an element.
 * @param  {Op} op   Operation to be applied. Contains path and op type.
 * @param  {DOMNode} DOMNode used as root element for path navigation.
 * @public
 */
function applyOp(op, rootElement) {
	let charIndex, attributeName;
	const path = op.p;
	if (path.length === 0) {
		return;
	}

	// We have to use "prop in obj" syntax, because not all properties have a value, necessarily
	// (i.e. `oi`).
	if ('si' in op || 'sd' in op) {
		// For string insertions and string deletions, we extract the character index from the path.
		charIndex = path.pop();
	}

	if ('oi' in op || 'od' in op) {
		// For attribute insertions and attribute deletions, we extract the attribtue name from the
		// path.
		attributeName = path.pop();
	}
	// Attribute insertion (object insertion). Also catches replace operations, i.e. operations with
	// both `oi` and `od`.
	if ('oi' in op) {
		return setAttribute(rootElement, path, attributeName, op.oi);
	}

	// Attribute removal (object deletion)
	if ('od' in op) {
		return removeAttribute(rootElement, path, attributeName);
	}

	// String deletion.
	if ('sd' in op) {
		return deleteInText(rootElement, path, charIndex, op.sd);
	}

	// String insertion.
	if ('si' in op) {
		return insertInText(rootElement, path, charIndex, op.si);
	}

	// Node replacement, either a regular node, tag renaming, or a complete replacement of
	// attributes.
	if ('li' in op &amp;&amp; 'ld' in op) {
		return replaceNode(rootElement, path, op.li);
	}

	// Element deletion operation (list deletion).
	if ('ld' in op) {
		return deleteNode(rootElement, path);
	}

	// Element insertion operation (list insertion).
	if ('li' in op) {
		return insertNode(rootElement, path, op.li);
	}
}

function applyOpReverse(op, rootElement) {
    let charIndex, attributeName;
    const path = op.p;
    if (path.length === 0) {
	return;
    }

    // We have to use "prop in obj" syntax, because not all properties have a value, necessarily
    // (i.e. `oi`).
    if ('si' in op || 'sd' in op) {
	// For string insertions and string deletions, we extract the character index from the path.
	charIndex = path.pop();
    }

    // No need to change
    if ('oi' in op || 'od' in op) {
	// For attribute insertions and attribute deletions, we extract the attribtue name from the
	// path.
	attributeName = path.pop();
    }
    // Attribute insertion (object insertion). Also catches replace operations, i.e. operations with
    // both `oi` and `od`.
    // SWAPED
    if ('oi' in op) {
	return removeAttribute(rootElement, path, attributeName);
    }

    // Attribute removal (object deletion)
    // SWAPED
    if ('od' in op) {
        return setAttribute(rootElement, path, attributeName, op.od);
	// return removeAttribute(rootElement, path, attributeName);
    }

    // String deletion.
    // SWAPED
    if ('sd' in op) {
        return insertInText(rootElement, path, charIndex, op.sd);
	// return deleteInText(rootElement, path, charIndex, op.sd);
    }

    // String insertion.
    // SWAPED
    if ('si' in op) {
        return deleteInText(rootElement, path, charIndex, op.si);
	// return insertInText(rootElement, path, charIndex, op.si);
    }

    // Node replacement, either a regular node, tag renaming, or a complete replacement of
    // attributes.
    // SWAPED
    if ('li' in op &amp;&amp; 'ld' in op) {
	return replaceNode(rootElement, path, op.ld);
    }

    // Element deletion operation (list deletion).
    // Swaped
    if ('ld' in op) {
        return insertNode(rootElement, path, op.ld); // CHECK this
	// return deleteNode(rootElement, path);
    }

    // Element insertion operation (list insertion).
    // Swaped
    if ('li' in op) {
	// return insertNode(rootElement, path, op.li);
        return deleteNode(rootElement, path);
    }
}



coreEvents.createEvent('receivedOpsStlkForward', { idempotent: true });
coreEvents.addEventListener('receivedOpsStlkForward', (rootElement, ops) =&gt; {

    try {
        
        coreMutation.pause();

        var op = ops
        applyOp(op, rootElement);
        
        coreMutation.resume();
        
    } catch (error) {}
    
}, coreEvents.PRIORITY.IMMEDIATE);


coreEvents.createEvent('receivedOpsStlk', { idempotent: true });
coreEvents.addEventListener('receivedOpsStlk', (rootElement, ops) =&gt; {
    // We disable the mutation observers before applying the operations. Otherwise, applying the
    // operations would cause new mutations to be created, which in turn would cause the
    // creation of new operations, leading to a livelock for all clients.

    try {

        coreMutation.pause();

        var op = ops
        applyOpReverse(op, rootElement);
        
        
        // And re-enable MuationObservers.
        coreMutation.resume();
        
    } catch (error) {}
    
    
}, coreEvents.PRIORITY.IMMEDIATE);


exports = Object.assign(exports, {coreEventsModule, PathTree})
</pre></div><div class="paragraph code-paragraph collapsed" data-id="Qr3KyE3e" name="opsProcessTimeline" run-on-load="true" last-execution-state="success"><pre data-type="content" type="text/javascript" id="opsProcessTimeline">const vm = Codestrate.VirtualMachines.get("text/javascript");

importLib([
    "lodash.min.js",
]).then(() =&gt; {

    
    // process states (success/error)
    const processStates = async (stateSelection) =&gt; {

        return stateSelection.map(event =&gt; ({
            globalIndex: event.globalIndex,
            version    : event.version,
            at:          new Date(event.timestamp),
            title:       event.version,
            link:        event.version,
            // group:       event.state == "success" ? 'success'               : 'error',
            group:       event.userId,
            className:   event.state == "success" ? 'entry--point--success' : 'entry--point--warn',
            symbol:      event.state == "success" ? 'symbolTriangle'        : 'symbolCross'
        }))

    }

    // generate objects for sessions 
    const processData = async (versioningParsed) =&gt; {

        var sessionObject,
            sessionGrouped;
        
        sessionObject = versioningParsed[0].opsOb.map(element =&gt; ({
            globalIndex: element.globalIndex,
            timestamp:   element.timestamp,
            version:     element.version,
            sessionId:   (Object.keys(element.opMeta).indexOf("sessionId") !== -1) ? element.opMeta.sessionId : 0,
            connectTime: (Object.keys(element.opMeta).indexOf("sessionId") !== -1) ? element.opMeta.connectTime : 0,
            userId:      (Object.keys(element.opMeta).indexOf("sessionId") !== -1) ? element.opMeta.userId : 0
        }))

        // INFO: filtering non-sessions
        sessionObject = Object.keys(sessionObject).map(key =&gt; sessionObject[key])
            .filter(element =&gt; (element.sessionId !== 0))

        // making Set to identify unique session and max/min
        sessionGrouped = _.chain(sessionObject)
            .groupBy("sessionId")
            .map(session =&gt; ({
                "sessionId": session[0]['sessionId'],
                "connectTime": session[0]['connectTime'],
                "users": [...new Set(_.map(session, "userId"))],
                "maxConnectTime": _.maxBy(session, "timestamp")['timestamp'],
                "minConnectTime": _.minBy(session, "timestamp")['timestamp'],
                "maxVersion": _.maxBy(session, "timestamp")['version'],
                "minVersion": _.minBy(session, "timestamp")['version'],
          			"maxGlobalIndex": _.maxBy(session, "timestamp")['globalIndex'],
                "minGlobalIndex": _.minBy(session, "timestamp")['globalIndex']
            })).value()

        console.log('Data is Processed Successfully, session-grouped:', sessionGrouped)
        return sessionGrouped
        
    }

    const createDataObject = async (sessionGrouped) =&gt; { // INFO: updating vue vis component

        return sessionGrouped.map(int =&gt; ({
            from: new Date(int.minConnectTime),
            to: new Date(int.maxConnectTime),
            title: int.sessionId,
            label: int.users,
            group: int.users,
            className: 'entry--point--default',
            version: {start: int.minVersion, end: int.maxVersion},
            globalIndex: {start: int.minGlobalIndex, end: int.maxGlobalIndex}
        }))

        console.log('Data Object is Created Successfully: ', sessionGrouped)
    };

    exports.processDataTml = async (localOpsState, stateSelection) =&gt; {

        // getting from versioning package
        var versioningParsed,
            sessionGrouped,
            statesProcessed,
            dt;

        // FIXME: remove redundant awaits
        versioningParsed = await localOpsState // done
        sessionGrouped = await processData(versioningParsed)
        statesProcessed = await processStates(stateSelection)
        console.log("Object with processed states for Timeline", statesProcessed)

        dt = await createDataObject(sessionGrouped)
        
        dt.push(...statesProcessed) // TODO: unite into one array
        vm.context.timelineFinalDataObject = dt // should be accessible in a dependency

    }

})</pre></div><div class="paragraph code-paragraph" data-id="uuwCK9Nh" name="opsUtils" last-execution-state="success"><pre data-type="content" type="text/javascript" id="opsUtils">// TODO: patching diff
// TODO: output
// TODO: vistrate
// SOLVED: get current element name

const ParagraphUtils = require("#paragraph-utils"),
    HelperFunctions = require("#helperFunctions"),
    coreWsClientModule = require("#coreWebstratesClientAPI"),
    opsProcessTimeline = require("#opsProcessTimeline"), // FIXME: temporary, remove later
    vm = Codestrate.VirtualMachines.get("text/javascript"),
    timeout = 200;

// receive array of ops from last til user-defined version
// input argument controls the range of received ops
// so, currentVersion - inputVersion
// by default, parse all
const getOps = (version) =&gt; {

    var tsd,
        version;
    
    version = typeof version === "undefined" &amp;&amp; webstrate.version; // if version is not specified, get the whole history

    webstrate.getOps(webstrate.version - version, webstrate.version, (x, y) =&gt; {
        tsd = y;
    });

    return new Promise((resolve, reject) =&gt; {

        const interval = setInterval(() =&gt; {

            if (!Array.isArray(tsd)) {} else {
                clearInterval(interval)
                resolve(tsd)
                console.log("Resolved", tsd)
            }
        }, timeout);


    });

};

// helper function to create containers for elements
const recOps = (paragraph) =&gt; {

    var el,
        target;

    el = paragraph.children[1].__pathNodes[0].children[0]
    target = {
        id: el.id,
        path: el.toPath()
    }

    return target;
}

// looks for execution changes in ops (fail/success)
var findRelevantStateChanges = async (target, ops) =&gt; {

    let ind,
        tmpArray

    var targetTmp,
        opContainer,
        opContainerBeforeMutation;

    ind = [];
    tmpArray = await ops;
    targetTmp = await [target]; // SOLVED: filter target to be unique

    targetTmp.forEach(cellLine =&gt; { // INFO: for each path of the cell line

        // cellLine.path
        tmpArray.forEach((el, index) =&gt; { // INFO: for each version

            // INFO: choosing only ops with the reference to execution state

            el.op !== undefined &amp;&amp; el.op.forEach(op =&gt; { // INFO: for each op

                // there are ops with path not possible to obtain
                // that is why we simply slice the last elements

                if ([...op.p].pop() == "last-execution-state" &amp;&amp; [...op.p].slice(-2)[0] == 1) {

                    // last element in an array - execution index
                    // one before last is always - 1
                    opContainer = [...op.p]
                    opContainerBeforeMutation = [...op.p]
                    opContainer = opContainer.slice(0, op.p.length - 2)
                    // console.log("opContainer to compare", opContainer)
                    // console.log("CellLine", cellLine)

                    // TODO: checking out this array
                    // if artefact and position are equal to the given one

                    // console.log(HelperFunctions.compareArrays(opContainer, cellLine.path))
                    HelperFunctions.compareArrays(opContainer, cellLine.__pathNodes[0].toPath()) &amp;&amp;
                        ind.push({
                            timestamp: el.m.ts,
                            opMeta: el.session,
                            realOp: op,
                            path: opContainerBeforeMutation,
                            version: el.v,
                            globalIndex: index // I also need to keep an index from global ops array
                        })

                }

            })

        })

    })

    return ind

}



// taking target PathTree + ops to process
const findRelevantPiecesInOps = async (target, ops) =&gt; {

    let ind,
        tmpArray;

    var targetTmp,
        opContainer,
        opContainerBeforeMutation;

    ind = [];
    tmpArray = await ops;

    targetTmp = await [target]; // SOLVED: filter target to be unique
    targetTmp.forEach(cellLine =&gt; { // INFO: for each path of the cell line

        // console.log("Celline",cellLine)
        // cellLine.path
        tmpArray.forEach((el, index) =&gt; { // INFO: for each version

            (el.op !== undefined) &amp;&amp; el.op.forEach(op =&gt; { // INFO: for each op

                // there are ops with path not possible to obtain
                // that is why we simply slice the last elements
                if (cellLine.path.length &lt; op.p.length) {

                    opContainer = [...op.p]
                    opContainerBeforeMutation = [...op.p]
                    opContainer.pop()

                    // console.log("Inspecting!", el)
                    HelperFunctions.compareArrays(opContainer, cellLine.path) &amp;&amp;
                        ind.push({
                            timestamp: el.m.ts,
                            opMeta: el.session,
                            realOp: op,
                            path: opContainerBeforeMutation,
                            version: el.v,
                            globalIndex: index,
                            change: HelperFunctions.FilterObjectByKey(op, "p") // filtering path
                        })

                } else {

                    opContainer = [...op.p]
                    HelperFunctions.compareArrays(opContainer, cellLine.path) &amp;&amp;
                        ind.push({
                            timestamp: el.m.ts,
                            opMeta: el.session,
                            realOp: op,
                            path: opContainer,
                            version: el.v,
                            globalIndex: index,
                            change: HelperFunctions.FilterObjectByKey(op, "p")
                        }) // filtering path

                }

            })

        })

    })

    return ind

}

// legacy fun
// sort ops by version and remove duplicates
const sortNclear = async (ind) =&gt; {

    var indLocal,
        indClear;

    indLocal = await ind;
    indLocal.sort(HelperFunctions.compareSort)

    // INFO: delete duplicates (legacy)

    indClear = indLocal.reduce((acc, value) =&gt; {

        if (acc.length &gt; 0) { // INFO: after second call I can compare
            // SOLVED: first two duplicates are not removed

            if (acc[acc.length - 1].version === value.version // INFO: comparing current with previous
                &amp;&amp;
                HelperFunctions.compareArrays(acc[acc.length - 1].path, value.path)) { // INFO: if previous is the same
                // INFO: not pushing duplicates
            } else {
                acc.push(value)
            }; // INFO: push unique (legacy)

        } else {
            acc.push(value)
        }; // INFO: if it is first call, just push (legacy)

        return acc

    }, [])


}

// used to find a proper ops quantity before navigation on contributors or state execution
// opsLocal - ops for the current code cell
// opsStatePromise - state-related ops for the current code cell
// navigateToArgument - global index, used for vis navigation
const calculateOpsQuantity = async (opsStatePromise, opsLocal, currentIndex, navigationalMode, artefactMode, navigateToArgument) =&gt; {

    var opsQuantity,
        ops = await opsStatePromise, // either ops with the state changes or contributor-specific slice
        opsLcl = await opsLocal,
        statesList = [], // mapping all state changes from undefined or success to error
        navigateTo, // next state to navigate to (execution artefact)
        closestOp, // this is the op I need to navigateTo
        finalClosestOp, // last op to be applied in case of contributor-based navigation
        step = 0; // used in cases when navigation direction changes

    // Using this for easing navigation through artefacts
    // vm.context.errorState - keeping index of the last error state navigated to
    // vm.context.currentIndex - index within local array of ops for a code cell
    // vm.context.globalIndex - index within the overall array of ops for the codestrate


   

    // TODO: inject to default, then to error/succes, then to contributor
    if ((navigationalMode == "backward" &amp;&amp; vm.context.lastAppliedOp.forwardOp) ||
        (navigationalMode == "forward" &amp;&amp; vm.context.lastAppliedOp.backwardOp)) {
        // fixme" naviugational mide"
        navigationalMode == "backward" ?
            step = -1 :
            step = +1
    }

    
    
    // I am already receiving filtered local ops object
    if (artefactMode == "contributor") {

        // calculate distance for all ops from current global index
        closestOp = opsStatePromise.nextContributorOps.map(el =&gt; {
            return {
                globalIndex : el.globalIndex,
                distance    : Math.abs(el.globalIndex - vm.context.globalIndex)
            }
        })

        // find distance, if possible, then reduce
        // next op to be applied
        closestOp = closestOp.length &gt; 1 &amp;&amp; closestOp.length
            ? closestOp.reduce((prev, curr) =&gt;  {
                return prev.distance &lt; curr.distance ? prev : curr;
            })
            : closestOp

        finalClosestOp = opsStatePromise.nextContributorOps.filter(el =&gt; el.globalIndex == closestOp.globalIndex)
        finalClosestOp = Array.isArray(finalClosestOp) ? finalClosestOp : [finalClosestOp]

        navigationalMode == "backward"
            ? opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == vm.context.globalIndex) -
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == finalClosestOp[0].globalIndex)
            : opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == finalClosestOp[0].globalIndex) - 
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == vm.context.globalIndex)
        
    } else if (artefactMode == "error" || artefactMode == "success") {
        
        // FIXME: might be several closest indexes
        // FIXME: currently, states are extracted outside of current function
        // consider this later
        // making a proper array of states

        ops.forEach(el =&gt; {
            
            if (el.realOp.od == "success" || el.realOp.od
                &amp;&amp; el.realOp.oi == "error") {
                
                statesList.push({globalIndex : el.globalIndex,
                                 state       : "error",
                                 distance    : el.globalIndex - vm.context.globalIndex})
                
            } else { // FIXME: assuming, that all other states are successfull

                statesList.push({globalIndex : el.globalIndex,
                                 state       : "success",
                                 distance    : el.globalIndex - vm.context.globalIndex})
            }
        })
        

        // FIXME:
        // if function is used to calculate distance from current index
        // to the specified by user state in the vis interface
        // index to navigate to is already know, so, no need to calculate it
        
        if (navigateToArgument) {

            // gets global Index of state
            navigateTo = statesList.filter(state =&gt; state.globalIndex == navigateTo)
            navigateTo = Array.isArray(navigateToArgument) ? navigateToArgument : [{globalIndex: navigateToArgument}]
            
        } else {

            // find the next state to navigate to considering current index
            // I need to consider the right sorting for this to work
            // filtering those state changes, which occured after/before current index

            navigationalMode == "backward"
                ? navigateTo = statesList.filter(state =&gt; (state.state == artefactMode) &amp;&amp;
                                                 ((state.globalIndex - vm.context.globalIndex) &lt; 0))
                : navigateTo = statesList.filter(state =&gt; (state.state == artefactMode) &amp;&amp;
                                                 ((state.globalIndex - vm.context.globalIndex) &gt; 0))

            // TODO: checking whether navigateTo is the same as the last time
            // if possible, then reduce
            
            navigateTo = navigateTo.length &gt; 1
                ? navigateTo.reduce((prev, curr) =&gt;  {
                    return prev.distance &lt; curr.distance ? prev : curr;
                })
                : navigateTo

            navigateTo = Array.isArray(navigateTo) ? navigateTo : [navigateTo]
            
            // if there is no next error exec. state, exit
            if (navigateTo.length == 0) { return }

            // if current error state Index is the same as the previous one
            if (navigateTo[0].globalIndex == vm.context.errorState) { return } else {
                
                // TODO: consider local index for state
                vm.context.errorState = navigateTo[0].globalIndex
                
                // ??? within and between states of different type
                // find the index of closest operational transformation to the state
                // var localErrorIndex,
                //     localSuccessIndex;
            }

        }

        // just realised, that some and every are the same as while and repeat
        // I need the first, which satisfies the condition
        // I am findig the closest state change
        // and looking for the closest index of the version for the corresponding code cell

        navigationalMode == "backward"
            ? closestOp = opsLcl[0].opsOb.filter(el =&gt; (el.globalIndex - vm.context.globalIndex) &lt; 0)
            : closestOp = opsLcl[0].opsOb.filter(el =&gt; (el.globalIndex - vm.context.globalIndex) &gt;= 0)

        // if there is something to reduce, do it
        closestOp = closestOp.length &gt; 1
            ? closestOp.reduce((prev, curr) =&gt;  {
                return (Math.abs(prev.globalIndex - navigateTo[0].globalIndex)) &lt; (Math.abs(curr.globalIndex - navigateTo[0].globalIndex)) ? prev : curr;
            })
            : closestOp
        
        // TODO: calculate number of operations given the opsLocal to get to the closestOp
        // this is the last operation to be performed

        closestOp = Array.isArray(closestOp) ? closestOp : [closestOp]
        navigationalMode == "backward"
            ? opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == vm.context.globalIndex) -
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == closestOp[0].globalIndex)
            : opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == closestOp[0].globalIndex) - 
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == vm.context.globalIndex)
        
    } else if (artefactMode == "default") {
        
        // TODO: get number of states withing localOps object

        navigationalMode == "backward"
            ? opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == (vm.context.globalIndex + step)) -
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == navigateToArgument)
            : opsQuantity = opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == navigateToArgument) - 
            opsLcl[0].opsOb.findIndex(el =&gt; el.globalIndex == (vm.context.globalIndex + step))
    }
    
    console.log("opsQuantity inside Fun", opsQuantity)
    return opsQuantity
    
}



// FIXME: fix navigation with multiple artefacts (does not working correctly)
// SOLVED: visible index is not synch with the global vm.context.globalIndex when mixing different navigations
// TODO: consider previous possible artefact navigations in ops calculation and application (some of the ops + indexing)
// fx, default navigation -&gt; error state navigation

// if direction changed from backward to forward
// ops are calculated -1 or

// if direction changed from forward to backward
// +1 mb

// if direction has not changed at all
// keep as it was


// use to prepare data object of code paragraphs execution information
// succeess/fail for a timeline
const prepareExecutionStatesObject = async (opsStatePromise) =&gt; {

    var ops = await opsStatePromise, // either ops with the state changes or contributor-specific slice
        statesList = [];

    // FIXME: might be several closest indexes
    // making a proper array of states
    ops.forEach(el =&gt; {

        if (el.realOp.od == "success" || el.realOp.od &amp;&amp;
            el.realOp.oi == "error") {

            statesList.push({
                globalIndex: el.globalIndex,
                userId: el.opMeta.userId,
                timestamp: el.timestamp,
                version: el.version,
                state: "error",
                distance: el.globalIndex - vm.context.globalIndex
            })

        } else { // FIXME: assuming, that all other states are successfull

            statesList.push({
                globalIndex: el.globalIndex,
                userId: el.opMeta.userId,
                timestamp: el.timestamp,
                version: el.version,
                state: "success",
                distance: el.globalIndex - vm.context.globalIndex
            })

        }

    })

    // FIXME: change mechanism later - use i/o model instead fo global
    // vm.context.statesListforTimeline = statesList

    statesList = Array.isArray(statesList) ? statesList : [statesList]
    
    return statesList

}


// FIXME: changeDirection for the multiple
// there are ops wiht the same version number
// should consider this mechanism

// apply only 1 operational transformation
// get ops on input 
// backward or forward - operationalMode
// returns promise with opsApplied to update the indcator of the current state

const processOpsAndApply = async (paragraph, ops, stateSelection, operationalMode) =&gt; {

    // I need to apply op to the transient pre instead of the original

    var rootTmp = document.querySelector("pre[versioning-id-to-remove='" +
        paragraph.getAttribute("name") + "']")


    console.log("Applying Op to this element", rootTmp)


    var opInst = await ops;
    // choose next op based on the current one to apply
    // index of opInst.opsOb is relative, absolute is used in UI (version)
    // derfor, filter opsOb and pass the proper absolute/relative indexes
    // TODO: try to use a linked list here
    var opTry;

    // first, find index within object of the current version
    // checking whether the next Op for code cell exists here
    // if not, rejecting promise
    // if it exists, I can apply op forward
    var unIndex;

    // FIXME: overcomplicated structure
    // I am not changing any version here
    // if the previous action was opposite to the current
    // I need to add/remove version here

    // rely on index rather than on version kept in the DOM
    // FIXME: it is temporary solution to use global scope
    // for keeping state
    // later, should rely either on cuex or DOM

    var st,
        duplVersion,
        unOp,
        changeDirectionInd = 0,
        step,
        updateFlag = false; // whether to update the index

    // flag for freezing versions in case of two consequtive equal versions
    // I don't need to update index in advance
    // if direction changed, I just need to reaply the same index
    vm.context.freezeVersion = false

    operationalMode == "backward" ?
        step = -1 :
        step = +1

    // used to understand when it is possible/impossible to navigate
    // also, it is handy to understand, whether index should be changed
    // duirng the current step
    // false means that current op is not applied in the maneer according to the key name
    // vm.context.lastAppliedOp = {forwardOp: false, backwardOp: false}

    if ((operationalMode == "backward" &amp;&amp; vm.context.lastAppliedOp.backwardOp) ||
        (operationalMode == "forward" &amp;&amp; vm.context.lastAppliedOp.forwardOp)) {
        // (vm.context.enteredMode)) { // catching first forward

        // if navgiation direction didn't change, assume application of the next op
        unOp = opInst.opsOb[vm.context.currentIndex + step]
        updateFlag = true

    } else {

        unOp = opInst.opsOb[vm.context.currentIndex]

    }

    if (unOp == undefined) {

        console.log("No" + operationalMode + " operation to apply")
        return
    }

    // if navigation direction changed, assume that the current op to be applied
    // if vm.context.enteredMode -&gt; navigation forward is not possible
    // after the first successful operation, assign false to variable
    if (vm.context.enteredMode &amp;&amp; opInst.opsOb[vm.context.currentIndex] != undefined &amp;&amp; operationalMode == "forward") {

        console.log("No next/previous version for the first forward Op")
        unIndex = false

    } else if (opInst.opsOb[vm.context.currentIndex] != undefined) { // checking whether it is possible to apply op

        // looking for the duplicates
        st = opInst.opsOb.map(el =&gt; el.version)
        duplVersion = st.map((e, i) =&gt; e === Number(stateSelection.version) ? i : undefined)
            .filter(x =&gt; x != undefined)

        // firstly, applying current operation
        // getting new index in the end
        unIndex = vm.context.currentIndex
        vm.context.freezeVersion = duplVersion.indexOf(vm.context.currentIndex) &gt; -1 &amp;&amp; duplVersion.length &gt; 1

        // console.log("vm.context.currentIndex", vm.context.currentIndex) 
        console.log("Op version", stateSelection.version)
        console.log("Forward Checking")
        // console.log("unIndex", unIndex)

    } else {

        console.log("No next/previous version")
        unIndex = false

    }

    return new Promise((resolve, reject) =&gt; {

        if (operationalMode === "backward" &amp;&amp; unIndex != false) {

            // main issue is that I need real ops, not helper objects I created
            opTry = Object.assign({}, unOp.realOp)
            var tmpPath = Object.assign([], unOp.path)
            opTry.p = tmpPath.splice(-2)
            console.log("Applying this op:", unOp)

            // changing the errorState index to keep it possible to navigate later
            // TODO: put into opsApplyMultiple and opsApply
            if (vm.context.lastArtefactNavigation != "error") vm.context.errorState = undefined
            coreWsClientModule.coreEventsModule.triggerEvent("receivedOpsStlk", rootTmp, opTry)
            resolve(unOp)

            // updating index and last step made only in case of navigation was successful
            if (updateFlag) vm.context.currentIndex = vm.context.currentIndex + step

            // updating global index to keep consistency between applyOpsMultiple and applyOp
            vm.context.globalIndex = opInst.opsOb[vm.context.currentIndex].globalIndex

            vm.context.lastAction = operationalMode
            vm.context.enteredMode = false
            vm.context.lastAppliedOp = {
                forwardOp: false,
                backwardOp: true
            }

        } else if (operationalMode === "forward" &amp;&amp; unIndex != false) {

            opTry = Object.assign({}, unOp.realOp)

            // don't understand why, but slicing does not working as expected 
            // that is why I am rewriting p with another path
            var tmpPath = Object.assign([], unOp.path)
            opTry.p = tmpPath.splice(-2)
            console.log("Applying this op:", unOp)

            // changing the errorState index to keep it possible to navigate later
            // TODO: put into opsApplyMultiple and opsApply
            if (vm.context.lastArtefactNavigation != "error") vm.context.errorState = undefined
            coreWsClientModule.coreEventsModule.triggerEvent("receivedOpsStlkForward", rootTmp, opTry)
            resolve(unOp)

            // updating index and last step made only in case of navigation was successful
            if (updateFlag) vm.context.currentIndex = vm.context.currentIndex + step

            // updating global index to keep consistency between applyOpsMultiple and applyOp
            vm.context.globalIndex = opInst.opsOb[vm.context.currentIndex].globalIndex

            vm.context.lastAction = operationalMode
            vm.context.enteredMode = false
            vm.context.lastAppliedOp = {
                forwardOp: true,
                backwardOp: false
            }

        } else if (typeof operationalMode === "undefined") {

            console.error("Specify operationalMode!")
            reject()

        } else if (unIndex == false) {

            console.error("There is no next/previous version for code chunk: ", stateSelection)
            reject()

        }

    })
}
// [1,2,3,4,5,6,7,8,10,11,12,13].forEach(el =&gt; {
//     opsLocal[HelperFunctions.getRandomArbitrary(0, opsLocal.length)]
//         .opMeta.userId = "stlk"
// })
// parse contributors


// TODO: get current contributor
// finds contributors and return object with contributors and filtered opsObject
const processOpsContributor = async (paragraph, ops) =&gt; {

    var opsLocal = ops,
        currentContributor = paragraph.getElementsByClassName("versioning-contributor")[0].children[0].innerText,
        nextContributor,
        contributors = [...new Set(opsLocal.opsOb.map(el =&gt; el.opMeta.userId))],
        nextContributorOps;


    // by default, just look for the closest operation
    // associated with the contributor, different from the current one

    // FIXME: assign index for contributors
    nextContributor = contributors.filter(contributor =&gt; contributor != currentContributor)

    nextContributorOps = opsLocal.opsOb.filter(el =&gt; el.opMeta.userId == (Array.isArray(nextContributor) ? nextContributor[0] : nextContributor))

    return {
        'contributors': contributors,
        'nextContributorOps': nextContributorOps
    }

}


// retursn promise
// apply several (how to define the proper scope) operational transformation
// number of ops to apply sequentilly 
// backward or forward
const processOpsAndApplyMultiple = async (paragraph, ops, stateSelection, operationalMode, opsQuantity) =&gt; {

    var rootTmp = document.querySelector("pre[versioning-id-to-remove='" +
            paragraph.getAttribute("name") + "']"),
        opInst = await ops,
        opTry,
        saveFlag = false, // whether to save the info about ops in the the loop or outside it's scope
        opIsApplied = false; // whether at least one op was applied in the loop


    // updating opsQuantity, if specified before amount cannot be applied
    // apply all existing ops
    if (operationalMode == "forward" &amp;&amp; // checking whether it is possible to go forward
        opInst.opsOb[vm.context.currentIndex] != undefined) {

        // if (!(vm.context.currentIndex + opsQuantity &lt; opInst.opsOb.length)) debugger;
        opsQuantity = vm.context.currentIndex + opsQuantity &lt; opInst.opsOb.length ?
            opsQuantity :
            opInst.opsOb.length - vm.context.currentIndex - 1

        console.log("Ops Quantity to go Forward", opsQuantity)

    } else if (operationalMode == "backward" &amp;&amp; // checking whether it is possible to go backward
        opInst.opsOb[vm.context.currentIndex] != undefined) {

        // if (!(vm.context.currentIndex - opsQuantity &gt; 0)) debugger;
        opsQuantity = (vm.context.currentIndex - opsQuantity &gt; 0) // backward indexing
            ?
            opsQuantity :
            vm.context.currentIndex

        console.log("Ops Quantity to go Backward", opsQuantity)

    } else {
        console.log("Specify operationalMode")
    }

    if (opsQuantity == 0) return

    // convention - index of applied operation is cached
    // first, check whether it is possible to apply this
    // number of operation per chunk if not, apply as maximum as possible

    // I am specifying direction in general case when ops is already applied
    // if there is no information per index, it is applicable either way
    // need to specify additional parameter for last index
    // meanwhile, when mode is entered, I should specify
    // that forward is not possible


    var opsToReturn = [],
        opTry,
        tmpPath,
        step,
        startingIndex; // used to catch the right op to be applied first

    return new Promise((resolve, reject) =&gt; {

        operationalMode == "backward" ?
            step = -1 :
            step = +1


        if ((operationalMode == "backward" &amp;&amp; vm.context.lastAppliedOp.forwardOp) ||
            (operationalMode == "forward" &amp;&amp; vm.context.lastAppliedOp.backwardOp)) {

            // specifying the case, when reached the end and cannot go back in history
            // if (!vm.context.enteredMode &amp;&amp; vm.context.lastAppliedOp.forwardOp &amp;&amp; vm.context.currentIndex == (opInst.opsOb.length - 1)) startingIndex = vm.context.currentIndex - 1
            if (!vm.context.enteredMode &amp;&amp; opInst.opsOb[vm.context.currentIndex + step * (-1)] &amp;&amp; vm.context.currentIndex == (opInst.opsOb.length - 1)) {
                // FIXME: look here with the 8
                startingIndex = vm.context.currentIndex + step * (-1) // if not just entered versioning mode
            } else {
                startingIndex = vm.context.currentIndex
                console.log("")
            }

        } else {
            // if navgiation direction didn't change, assume application of the next op
            startingIndex = vm.context.currentIndex + step
        }




        if (operationalMode === "backward") {

            for (var i = startingIndex; i &gt;= startingIndex - opsQuantity; i--) {

                // if cannot apply op
                if (opInst.opsOb[i] == undefined) {

                    // TODO: memorise last applied op
                    console.error("No more ops to be applied")
                    saveFlag = true

                    // FIXME: if at least one op was applied
                    if (opIsApplied) { // if at least one op was applied, saving it

                        vm.context.lastAppliedOp = {
                            forwardOp: false,
                            backwardOp: true
                        }
                        vm.context.enteredMode = false
                        vm.context.lastAction = operationalMode // specifying direction of the last navigation
                        vm.context.currentIndex = i + 1 // previous op
                        resolve(opsToReturn[opsToReturn.length - 1]) // returning info about last op

                    } else {
                        reject()
                    }


                    break;

                } else {


                    opTry = Object.assign({}, opInst.opsOb[i].realOp)
                    tmpPath = Object.assign([], opInst.opsOb[i].path)
                    opTry.p = tmpPath.splice(-2)

                    // global index from the entire ops to identify proper
                    // execution state for the code cell
                    vm.context.enteredMode = false
                    opIsApplied = true
                    vm.context.globalIndex = opInst.opsOb[i].globalIndex

                    // changing the errorState index to keep it possible to navigate later
                    // TODO: put into opsApplyMultiple and opsApply
                    if (vm.context.lastArtefactNavigation != "error") vm.context.errorState = undefined
                    try {
                        coreWsClientModule.coreEventsModule.triggerEvent("receivedOpsStlk", rootTmp, opTry)
                    } catch (error) {}
                    opsToReturn.push(opInst.opsOb[i])

                }
            }

            if (!saveFlag) { // if loop wasn't interrupted

                console.log("Global Index After Ops", vm.context.globalIndex)
                console.log("Last Op Applied", opInst.opsOb[opsToReturn.length - 1].realOp)

                // transfered update of currentIndex here
                vm.context.currentIndex = startingIndex - opsQuantity
                vm.context.lastAppliedOp = {
                    forwardOp: false,
                    backwardOp: true
                }
                vm.context.lastAction = operationalMode // specifying direction of the last navigation

                resolve(opsToReturn[opsToReturn.length - 1]) // returning info about last op

            }


        } else if (operationalMode === "forward") {

            // FIXME: exclude = from &gt; if the direction changed and current op applied
            // FIXME: configure integrity with the 1-step ops applier

            for (var i = startingIndex; i &lt;= startingIndex + opsQuantity; i++) {

                // if cannot apply op
                if (opInst.opsOb[i] == undefined) {

                    // TODO: memorise last applied op
                    console.error("No more ops to be applied")
                    saveFlag = true

                    // FIXME: if at least one op was applied
                    if (opIsApplied) { // if at least one op was applied, saving it

                        vm.context.lastAppliedOp = {
                            forwardOp: true,
                            backwardOp: false
                        }
                        vm.context.enteredMode = false
                        vm.context.lastAction = operationalMode // specifying direction of the last navigation
                        vm.context.currentIndex = i - 1 // previous op
                        resolve(opsToReturn[opsToReturn.length - 1]) // returning info about last op

                    } else {
                        reject()
                    }


                    break;

                } else {

                    opTry = Object.assign({}, opInst.opsOb[i].realOp)
                    tmpPath = Object.assign([], opInst.opsOb[i].path)
                    opTry.p = tmpPath.splice(-2)

                    // global index from the entire ops to identify proper
                    // execution state for the code cell
                    vm.context.enteredMode = false
                    opIsApplied = true
                    vm.context.globalIndex = opInst.opsOb[i].globalIndex

                    // changing the errorState index to keep it possible to navigate later
                    // TODO: put into opsApplyMultiple and opsApply
                    if (vm.context.lastArtefactNavigation != "error") vm.context.errorState = undefined
                    try {
                        coreWsClientModule.coreEventsModule.triggerEvent("receivedOpsStlkForward", rootTmp, opTry)
                    } catch (error) {}
                    opsToReturn.push(opInst.opsOb[i])
                }
            }

            if (!saveFlag) { // if loop wasn't interrupted

                console.log("Global Index After Ops", vm.context.globalIndex)
                console.log("Last Op Applied", opInst.opsOb[opsToReturn.length - 1].realOp)

                vm.context.lastAppliedOp = {
                    forwardOp: true,
                    backwardOp: false
                }
                vm.context.currentIndex = startingIndex + opsQuantity
                vm.context.lastAction = operationalMode // specifying direction of the last navigation

                resolve(opsToReturn[opsToReturn.length - 1]) // returning info about last op

            }


        } else if (typeof operationalMode === "undefined") {
            console.error("Specify operationalMode!")
            reject()
        }
    })
}



// looks for the corresponding opsObject for paragraph
const getOpsFromCuex = (paragraph, cuex) =&gt; {

    var paragraphId = paragraph.getAttribute("data-id")
    console.log("paragraphId", paragraphId)

    return new Promise((resolve, reject) =&gt; {

        const interval = setInterval(() =&gt; {

            if (typeof cuex === "undefined") {


                console.log("Storage for paragraph is Empty!", cuex)

            } else {

                clearInterval(interval)
                var localOpObject = cuex.filter(el =&gt; {
                    return (el["paragraphId"] === paragraphId) &amp;&amp; el
                })
                console.log("Storage for paragraph is Accessed:", localOpObject)

                resolve(localOpObject)

            }

        }, timeout);


    })


}

// adds ops per paragraph to the global scope
const saveOps = async (paragraph, ops) =&gt; {

    // if ops loaded for the first time
    // means, cuex=opsStorage is null

    var paragraphId;
    
    let vm,
        cuex;

    paragraphId = paragraph.getAttribute("data-id")

    if (typeof cuex === "undefined") {

        console.log("Creating Cuex Storage")

        vm = Codestrate.VirtualMachines.get("text/javascript");
        cuex = []
        vm.addToGlobalContext({
            cuex
        })

        cuex.push({
            "paragraphId": paragraphId,
            "opsOb": await ops
        })
        console.log("Cuex is Updated after creation with", cuex)

    } else {

        // FIXME
        // if corresponding opsObject is already present, delete and add new
        // var cuexInd = cuex.filter((el, index) =&gt; {if (el["paragraphId"] === paragraphId) return index})
        // cueInd &gt; -1 &amp;&amp; cuex[cueInd] &amp;&amp; console.log("Cleaned Stale opsObject for paragraph ")

        cuex.push({
            "paragraphId": paragraphId,
            "opsOb": await ops
        })
        console.log("Cuex is Updated", cuex)

    }
}

// parses ops per a paragraph
// is used in enter/exit of the mode
const mainWrapper = async (paragraph) =&gt; {

    var target,
        ops,
        ind,
        acc,
        localOpsState,
        statesListForTimeline;

    target = recOps(paragraph)
    console.log(target)

    ops = getOps().then((dt) =&gt; {
        return dt
    })
    console.log("All Ops", ops)

    // TODO: rewrite later to use cuex instead 
    vm.context.stateOps = findRelevantStateChanges(paragraph, ops)
    console.log("Execution State Related Ops are Extracted", vm.context.stateOps)


    ind = await findRelevantPiecesInOps(target, ops)
    console.log("Relevant Ops", ind)


    // changing globalIndex of the last op 
    // it it supposed to be used later in the beginning of the navigation
    vm.context.globalIndex = ind[ind.length - 1].globalIndex

    acc = sortNclear(ind)
    console.log("Sorting and Duplicates Removal", acc)

    // debugger;

    acc = ind

    saveOps(paragraph, acc) // get ops and save them
    console.log("Ops are save to Cuex", acc)


    // preparing data for timeline before navigation starts
    localOpsState = getOpsFromCuex(paragraph, vm.context.cuex); // TODO: getOpsFromCuex into wrapper
    statesListForTimeline = await prepareExecutionStatesObject(vm.context.stateOps) // TODO: calculateOpsQuantity - part of it to a separete function
    opsProcessTimeline.processDataTml(localOpsState, statesListForTimeline) // FIXME: delete later

    return acc

}


exports = Object.assign(exports, {
    timeout,
    recOps,
    findRelevantPiecesInOps,
    findRelevantStateChanges,
    getOps,
    sortNclear,
    calculateOpsQuantity,
    prepareExecutionStatesObject,
    processOpsAndApply,
    processOpsAndApplyMultiple,
    processOpsContributor,
    getOpsFromCuex,
    saveOps,
    mainWrapper
})


</pre></div><div class="paragraph code-paragraph" data-id="3widdW9p" name="Versioning Utils" last-execution-state="success" style="" draggable="false" run-on-load="true"><pre data-type="content" type="text/javascript" id="versioning-utils">const opsUtils = require("#opsUtils"),
      ParagraphUtils = require("#paragraph-utils"),
      coreWsClientModule = require("#coreWebstratesClientAPI"),
      opsProcessTimeline = require("#opsProcessTimeline"), // FIXME: temporary, remove later
      vm = Codestrate.VirtualMachines.get("text/javascript");

// TODO: memorising last successfull artefact mode,
// since it is the easiest, though, not elegant way
// to keep the consistency in different types of navigation
// given current implementation
// vm.context.lastArtefactNavigation = {"default", "success", "error", "contributor"}

// assumption: in case of interval, jump to the beginning of the session
// in case of state, just jump to the state
// TODO: enhancmenet - find closest successful state and navigate to
// TODO: global todo - incorporate diff patches intogether

// since operationalMode and artefactMode is unknown,
// need to consturct those vars from vis objects user points to
// return operationalMode and artefactMode
const navigatePrepareInputs = (entry) =&gt; {

    var operationalMode,
        artefactMode,
        visObjectIndex; // container for index-related info about current vis object user points to

    visObjectIndex = entry.hasOwnProperty("from") &amp;&amp; entry.hasOwnProperty("to")
        ? entry.globalIndex.start
        : entry.globalIndex

    if (vm.context.globalIndex - visObjectIndex &gt; 0) {
        operationalMode = "backward"
    } else if (vm.context.globalIndex - visObjectIndex &lt; 0) {
        operationalMode = "forward"
    } else {
        console.error("Already on possition of current vis object's index")
        return {operationalMode: undefined, artefactMode: undefined}
    }

    // alignment for nested ternaries sucks
    // artefactMode should be known after parsing info from vis object
    artefactMode = entry.hasOwnProperty("from") &amp;&amp; entry.hasOwnProperty("to")
        ? "default"
        : entry.symbol == "symbolTriangle" // means, successfull execution
        ? "success"
        : "error"

    return {operationalMode, artefactMode, visObjectIndex}

}

// temporarily, keep paragraph in a global scope as well 
// entry as input
// FIXME: operationalMode pops up twice
const navigateVis = async(paragraph, operationalMode, artefactMode, visObjectIndex) =&gt; {

    if (!operationalMode) {
        console.error("Cannot navigate via Vis interface")
        return
    }

    var localOpsState,
        stateSelection,
        meta = {},
        opsQuantity;
    
    localOpsState = await opsUtils.getOpsFromCuex(paragraph, vm.context.cuex);
    stateSelection = await chooseOpBeforeApply(paragraph);
    opsQuantity = await opsUtils.calculateOpsQuantity(vm.context.stateOps, localOpsState, vm.context.globalIndex, operationalMode, artefactMode, visObjectIndex);
    
    if (opsQuantity &gt; 0 || opsQuantity != undefined) {
        meta["ops"] = await opsUtils.processOpsAndApplyMultiple(paragraph, localOpsState[0],
                                                                stateSelection, operationalMode, opsQuantity)
    } else {
        console.error("Cannot move via Vis Interface")
        return
    }
    
    await updateEditor(paragraph, meta["ops"]);
    await updateIndicators(paragraph, meta, operationalMode);
    
    console.log("Vis Navigation")
    console.log("stateOps", vm.context.stateOps)
    console.log("opsQuantity", opsQuantity)
    
}


vm.addToGlobalContext({
    navigateVis,
    navigatePrepareInputs
});

const toggleArtefact = async (paragraph, operationalMode, artefactMode) =&gt; {

    vm.context.lastArtefactNavigation = artefactMode

    var localOpsState,
        stateSelection,
        localContributorState,
        opsQuantity,
        meta = {};

    localOpsState = await opsUtils.getOpsFromCuex(paragraph, vm.context.cuex);
    stateSelection = await chooseOpBeforeApply(paragraph);

    // contributor-based or state-based navigation
    // TODO: make a snippet ES6 instead of switch case
    if (['success', 'error'].includes(artefactMode)) {
        opsQuantity = await opsUtils.calculateOpsQuantity(vm.context.stateOps, localOpsState, vm.context.globalIndex, operationalMode, artefactMode, operationalMode)
    } else {
        localContributorState = await opsUtils.processOpsContributor(paragraph, localOpsState[0])
        opsQuantity = await opsUtils.calculateOpsQuantity(localContributorState, localOpsState, vm.context.globalIndex, operationalMode, artefactMode, operationalMode)
    }

    if (opsQuantity &gt; 0 || opsQuantity != undefined) {
        await opsUtils.processOpsAndApplyMultiple(paragraph, localOpsState[0],
                                                  stateSelection, operationalMode, opsQuantity)
    } else {
        console.error("No " + operationalMode + " " + artefactMode + " to follow")
        return
    }
    
    // universal
    await updateEditor(paragraph, meta["ops"]);
    await updateIndicators(paragraph, meta, operationalMode);

    console.log(operationalMode + " " + artefactMode + " Navigation")
    console.log("stateOps", vm.context.stateOps)
    console.log("opsQuantity", opsQuantity)
    
}


// unites tiny and cardinal
// FIXME: add an argument
const toggleDefaultNavigation = async (paragraph, operationalMode, contextArgument) =&gt; {

    vm.context.lastArtefactNavigation = "default"
    
    var localOpsState,
        stateSelection,
        meta = {};

    localOpsState = await opsUtils.getOpsFromCuex(paragraph, vm.context.cuex);
    stateSelection = await chooseOpBeforeApply(paragraph);

    switch (contextArgument) {
    case "modular":
        
        meta["ops"] = await opsUtils.processOpsAndApply(paragraph, localOpsState[0], stateSelection, operationalMode)
        await updateEditor(paragraph, meta["ops"]);
        
        break;
    case "cardinal":

        meta["ops"] = await opsUtils.processOpsAndApplyMultiple(paragraph, localOpsState[0], stateSelection, operationalMode, 5)
        try {
            await updateEditor(paragraph, meta["ops"][meta["ops"].length - 1]);
        } catch (error) {
            console.error("Cannot go " + operationalMode)
        }
        
        break;
        
    }
    
    await updateIndicators(paragraph, meta, operationalMode);
    console.log(operationalMode + " " + contextArgument);

}

// defines another abstratction to choose proper ops to apply
// or incorporate them into already existing function
// better write a middleware

const chooseOpBeforeApply = (paragraph) =&gt; {
    
    return new Promise((resolve,reject) =&gt; {
        
        const interval = setInterval(() =&gt; {
            
            var version = paragraph.getElementsByClassName("versioning-v-number")[0].children[0].innerText,
                contributor = paragraph.getElementsByClassName("versioning-contributor")[0].children[0].innerText,
                currentIndex = paragraph.getElementsByClassName("versioning-v-number")[0].children[0].getAttribute("current-index");
            
            if (typeof version === "undefined" &amp;&amp; typeof contributor === "undefined") {
         	console.log("OpsSelector is not yet Resolved")
            } else {
                
         	clearInterval(interval)
                resolve(
                    {"version"    : version, 
          	     "contributor": contributor,
                     "index"      : currentIndex}
          	)
         	console.log("OpsSelector is Resolved,", version, contributor, currentIndex)
            }
        }, 300);
        
    })
}


// function for editor update
// second argument is the promise from opsApply function
const updateEditor = async (paragraph, promise) =&gt; {
    
    // deletes old editor
    paragraph.getElementsByClassName("CodeMirror cm-s-monokai CodeMirror-wrap")[0].remove()
    
    var codeContainer = document.querySelector("pre[versioning-id-to-remove='" +
                                               paragraph.getAttribute("name") + "']" )
    try {
        
    	codestrate.editors.CodeMirror
  	    .factory.create(paragraph.getElementsByClassName("editor default-editor CodeMirror")[0], 
                            codeContainer)
        
    } catch {
      	console.log("Updated Editor")
    } 
    
}

// a function to update indicators
// takes object meta (returned from opsApply) or object from cuex, 

// FIXME: instead of relying on return from opsApply
// rely on chooseIndicator helper + mode

// if nothing meta is not specified
// FIXME: update indicators based on mode - forward/backward (mode)
const updateIndicators = async (paragraph, meta, mode, artefactMode) =&gt; {
    
    
    // using in case when current index is after the error execution state
    artefactMode &amp;&amp; artefactMode == "error" &amp;&amp; 
        paragraph.getElementsByClassName("toggle-versioning-mode")[0].classList.add("failure")
    
    artefactMode &amp;&amp; artefactMode == "success" &amp;&amp; 
        paragraph.getElementsByClassName("toggle-versioning-mode")[0].classList.remove("failure")
    
    var nextVersion = mode === "forward" ? +1 : -1  
    
    // update indicator when entering mode without mutating the version
    if (typeof meta === "undefined") {
   	
        console.log("Meta is undefined!")
        meta = await opsUtils.getOpsFromCuex(paragraph, vm.context.cuex)
        vm.context.currentIndex = meta[0].opsOb.length - 1
        
        paragraph.getElementsByClassName("versioning-v-number")[0].children[0]
            .setAttribute("current-index", meta[0].opsOb.length - 1)
        
        paragraph.getElementsByClassName("toggle-versioning-mode")[0].classList.add("v-active")
        paragraph.getElementsByClassName("versioning-v-number")[0].children[0].innerText = meta[0].opsOb[meta[0].opsOb.length - 1].version // first run
        paragraph.getElementsByClassName("versioning-contributor")[0].children[0].innerText = meta[0].opsOb[meta[0].opsOb.length - 1].opMeta.userId
        
    } else {
   	
        console.log("Ops are recieved", meta)
        
        // updates only currentIndex, keeping version
        if (vm.context.freezeVersion == true) {
            
            paragraph.getElementsByClassName("versioning-v-number")[0].children[0].setAttribute("current-index", vm.context.currentIndex)
            console.log("Curent Index is:", vm.context.currentIndex)
            return
            
        }
        
        // showing the version of the next op to be reversed
        paragraph.getElementsByClassName("toggle-versioning-mode")[0].classList.add("v-active")
        
        if (meta.ops != undefined) {
            
            paragraph.getElementsByClassName("versioning-v-number")[0].children[0].innerText = meta.ops.version
            paragraph.getElementsByClassName("versioning-contributor")[0].children[0].innerText = meta.ops.opMeta.userId
            
        }
        
        paragraph.getElementsByClassName("versioning-v-number")[0].children[0]
            .setAttribute("current-index", vm.context.currentIndex)
        
    }
    
}

// changes artefact for navigation
const changeNavigationArtefact = async (pg) =&gt; {
    
    var clsList = pg.getElementsByClassName("change-artefact")[0].classList
    
    // console.log("Change Artefact")
    // console.log(clsList.contains("changed-1"))
    
    clsList.contains("changed-1")
    
    switch(true) {

    case clsList.contains("changed-1"):
        pg.getElementsByClassName("change-artefact")[0].classList.remove("changed-1");
        pg.getElementsByClassName("change-artefact")[0].classList.add("changed-2");
        break;
    case clsList.contains("changed-2"):
        pg.getElementsByClassName("change-artefact")[0].classList.remove("changed-2");
        pg.getElementsByClassName("change-artefact")[0].classList.add("changed-3");
        break;
    case clsList.contains("changed-3"):
        pg.getElementsByClassName("change-artefact")[0].classList.remove("changed-3");
        pg.getElementsByClassName("change-artefact")[0].classList.add("default");
        break;
    case clsList.contains("default"):
        pg.getElementsByClassName("change-artefact")[0].classList.remove("default");
        pg.getElementsByClassName("change-artefact")[0].classList.add("changed-1");
        break;
        
    }
    
    
}

// enter or exit versioning mode
// pg - paragraph
// content - innerText of code paragraph
const enterVersioningMode = async (pg) =&gt; {
    
    var initContent = pg.children[1],
        content = document.getElementById("save-container-" + pg.getAttribute) === null 
  	? initContent.innerText
        : document.getElementById("save-container-" + pg.getAttribute).innerText
    
    
    
    if (pg.getElementsByClassName("toggle-versioning-mode")[0]
        .getAttribute("class").indexOf("v-active") &gt; -1) { // exit mode
        
        vm.context.paragraph = null
        vm.context.enteredMode = false // used to not allow the first forward op to be applied
        vm.context.lastAppliedOp = {forwardOp: false, backwardOp: false}
        
        // changes the indicator
        pg.getElementsByClassName("toggle-versioning-mode")[0].classList.remove("v-active")
        pg.getElementsByClassName("versioning-v-number")[0].children[0].innerText = ""
        pg.getElementsByClassName("versioning-v-number")[0].children[0].setAttribute("current-index", "")
        pg.getElementsByClassName("versioning-contributor")[0].children[0].innerText = ""
        
        // deletes save-container
	document.getElementById("save-container-" + pg.getAttribute("name")).remove()
        pg.getElementsByClassName("transient-save")[0].remove() // delete the whole transient element
        
        
        // deletes old editor
	pg.getElementsByClassName("CodeMirror cm-s-monokai CodeMirror-wrap")[0].remove()
        
        try {
            
    	    codestrate.editors.CodeMirror
  		.factory.create(pg.getElementsByClassName("editor default-editor CodeMirror")[0], 
      			        pg.getElementsByTagName("pre")[0])
            
        } catch {
      	    
      	    console.log("Exit Versioning Mode")
            
        }      	 
        
    } else { // enter mode
        
        // fetching ops history to retrive ops per paragraph 
        var meta = await opsUtils.mainWrapper(pg);
        
        vm.context.paragraph = pg // used for navigation via vis interface
        vm.context.enteredMode = true // used to not allow the first forward op to be applied
        vm.context.lastAppliedOp = {forwardOp: true, backwardOp: false}
        // false means that current op is not applied in the maneer according to the key name
        
        // updating indicator
        updateIndicators(pg)
        pg.getElementsByClassName("toggle-versioning-mode")[0].classList.add("v-active")
        
	const transientContainer = document.createElement("transient")
        transientContainer.classList.add("transient-save")
        
        
	const codeContainer = document.createElement("pre");
        const textNode = document.createTextNode(content); 
        codeContainer.setAttribute("versioning-id-to-remove", pg.getAttribute("name"))
	codeContainer.setAttribute("data-type", "content");
	codeContainer.setAttribute("type", "text/javascript");
	codeContainer.appendChild(textNode);
        
        
        // deep copy already existing node (persisten path Node)
        // FIXME: check, whether it will be observed
        coreWsClientModule.PathTree(codeContainer)
        
	transientContainer.appendChild(codeContainer);
	pg.appendChild(transientContainer)
        
        
        // before removing node, save to DOM to restore from it later
        // TODO: auto-naming for code chunks?
        // keep ID in the header?
        
        // to work correctly, paragraph name should be provided
        // don't need to remove previous pre
  	var containerSaveParagraph = document.createElement("transient")
  	containerSaveParagraph.setAttribute("id", "save-container-" + pg.getAttribute("name"))
  	containerSaveParagraph.setAttribute("class", "hidden")
  	containerSaveParagraph.style.display = "none"
  	containerSaveParagraph.innerText = content
        document.body.appendChild(containerSaveParagraph)
        
        
        // removing old editor
        pg.getElementsByClassName("editor default-editor CodeMirror")[0].children[0].remove()
        
        try {

            // updates code editor
            codestrate.editors.CodeMirror
                .factory.create(pg.getElementsByClassName("editor default-editor CodeMirror")[0],
                                codeContainer)
            
        } catch {
            
      	    console.log("Updated Editor")
            
        }
        
    }

}


exports = Object.assign(exports, {toggleArtefact, toggleDefaultNavigation,
                                  enterVersioningMode, changeNavigationArtefact})
</pre></div><div class="paragraph code-paragraph" data-id="Cqhpj3an" name="Versioning UI" last-execution-state="success" run-on-load="true"><pre data-type="content" type="text/javascript" id="versioning-ui">const VersioningUtils = require("#versioning-utils");

// Bindings for artefact navigation should only work 
// for buttons named "cardinal", when the mode changes

// FIXME: discrepancy in terminology: navigationalMode == operationalMode
const navigationDefiner = (pg, navigationalMode) =&gt; {

    var clsList = pg.getElementsByClassName("change-artefact")[0].classList,
        artefactMode;
    
    switch(true) {

        // TODO: artefact mode
    case clsList.contains("changed-1"): // error navigation
        artefactMode = "error"
        break;
    case clsList.contains("changed-2"): // success navigation
        artefactMode = "success"
        break;
    case clsList.contains("changed-3"): // contributor navigation
        artefactMode = "contributor"
        break;
    case clsList.contains("default"): // default navigation
        artefactMode = "default"
        break;
    }

    if ([artefactMode].includes("error", "success", "contributor")) {
        return VersioningUtils.toggleArtefact(pg, navigationalMode, artefactMode)
    } else {
        // FIXME: contextArgument instead of artefactMode
        return VersioningUtils.toggleDefaultNavigation(pg, navigationalMode, artefactMode)
    }
}

importLib([
    "hammer.min.js",
    "hammer-time.min.js"
]).then(() =&gt; {

    const ParagraphUtils = require("#paragraph-utils");

    let addVersioningButton = (paragraph) =&gt; {

	let header = ParagraphUtils.getHeaderElement(paragraph);

	// Make sure to add action only once, e.g. triggered multiple times on paragraph drag and drop
	if (header.querySelector(".toggle-versioning-back-tiny")) {
	    return;
	}

        // Back tiny
	let actionBackTiny = document.createElement("div");
	actionBackTiny.classList.add("action");
	actionBackTiny.classList.add("toggle-versioning-back-tiny");
	actionBackTiny.setAttribute("tooltip", "true");
	
	let iconBackTiny = document.createElement("i");
	iconBackTiny.classList.add("material-icons");
	actionBackTiny.appendChild(iconBackTiny);
	header.appendChild(actionBackTiny);

        // Back cardinal
	let actionBackCardinal = document.createElement("div");
	actionBackCardinal.classList.add("action");
	actionBackCardinal.classList.add("toggle-versioning-back-cardinal");
	actionBackCardinal.setAttribute("tooltip", "true");
	
	let iconBackCardinal = document.createElement("i");
	iconBackCardinal.classList.add("material-icons");
	actionBackCardinal.appendChild(iconBackCardinal);
	header.appendChild(actionBackCardinal);

        // Forward Tiny
	let actionForwardTiny = document.createElement("div");
	actionForwardTiny.classList.add("action");
	actionForwardTiny.classList.add("toggle-versioning-forward-tiny");
	actionForwardTiny.setAttribute("tooltip", "true");
	
	let iconForwardTiny = document.createElement("i");
	iconForwardTiny.classList.add("material-icons");
	actionForwardTiny.appendChild(iconForwardTiny);
	header.appendChild(actionForwardTiny);

        // Forward cardinal
	let actionForwardCardinal = document.createElement("div");
	actionForwardCardinal.classList.add("action");
	actionForwardCardinal.classList.add("toggle-versioning-forward-cardinal");
	actionForwardCardinal.setAttribute("tooltip", "true");
	
	let iconForwardCardinal = document.createElement("i");
	iconForwardCardinal.classList.add("material-icons");
	actionForwardCardinal.appendChild(iconForwardCardinal);
	header.appendChild(actionForwardCardinal);
        
        // change artefact for navigation
        
        let artefact = document.createElement("div");
	artefact.classList.add("action"); 
	artefact.classList.add("change-artefact");
        artefact.classList.add("default");
	artefact.setAttribute("tooltip", "true");
	
	let iconArtefact = document.createElement("i");
	iconArtefact.classList.add("material-icons");
	artefact.appendChild(iconArtefact);
	header.appendChild(artefact);
        
        
        // indicator that mode that versioning mode is enabled 
        let versioningMode = document.createElement("div");
	versioningMode.classList.add("action"); 
	versioningMode.classList.add("toggle-versioning-mode");
	versioningMode.setAttribute("tooltip", "true");
	
	let iconVersioningMode = document.createElement("i");
	iconVersioningMode.classList.add("material-icons");
	versioningMode.appendChild(iconVersioningMode);
	header.appendChild(versioningMode);
        
        // current version indicator
        
        let versionNumberIndicator = document.createElement("div");
	versionNumberIndicator.classList.add("versioning-v-number");
	versionNumberIndicator.setAttribute("tooltip", "true");
        
        let versionText = document.createElement("p")
        versionText.innerText = ""
        versionNumberIndicator.appendChild(versionText)
        header.appendChild(versionNumberIndicator)   
        
        
        // current contributor indicator
        
        let versionContributorIndicator = document.createElement("div");
	versionContributorIndicator.classList.add("versioning-contributor");
	versionContributorIndicator.setAttribute("tooltip", "true");
        
        let versionContributorText = document.createElement("p")
        versionContributorText.innerText = ""
        versionContributorIndicator.appendChild(versionContributorText)
        header.appendChild(versionContributorIndicator)   
        

        try {
            
            [{action: actionBackTiny,        desc: "actionBackTiny"}, 
             {action: actionBackCardinal,    desc: "actionBackCardinal"},
             {action: actionForwardTiny,     desc: "actionForwardTiny"}, 
             {action: actionForwardCardinal, desc: "actionForwardCardinal"},
             {action: versioningMode,        desc: "versioningMode"},
             {action: artefact,              desc: "changeArtefact"}].forEach(action =&gt; {

                 var mc = new Hammer.Manager(action.action);
                 
	         mc.add(new Hammer.Tap({
	             event: "tap",
	             taps: 1
	         }));

	         mc.add(new Hammer.Press({
	             event: "longpress",
	             time: 250
	         }));


                 // FIXME: artefactMode as input
                 // new ES6 notation is more convenient than switch statements
                 if (['actionBackTiny', 'actionBackCardinal'].includes(action.desc)) {

                     action.desc == "actionBackTiny"
                         ? contextArgument = "modular"
                         : contextArgument = "cardinal"
                     
                     return  mc.on("tap", () =&gt; {
                         navigationDefiner(paragraph, "backward", contextArgument)
	             });
                     
                 } else if (["actionForwardTiny", "actionForwardCardinal"].includes(action.desc)) {

                     action.desc == "actionForwardTiny"
                         ? contextArgument = "modular"
                         : contextArgument = "cardinal"
                     
                     return  mc.on("tap", () =&gt; {
                         navigationDefiner(paragraph, "forward", contextArgument)
	             });
                     
                 } else if (action.desc == "versioningMode") {

                     return mc.on("tap", () =&gt; {
                         VersioningUtils.enterVersioningMode(paragraph);
                     })
                     
                 } else if (action.desc == "changeArtefact") {

                     return mc.on("tap", () =&gt; {
                         VersioningUtils.changeNavigationArtefact(paragraph);
                     })

                 }
                 
             })
            
        } catch {
            
            console.log("Error!");
            
        }
        
    };

    document.liveQuerySelectorAll(".paragraph").added(paragraph =&gt; {

        // only code paragraphs
        if (!paragraph.querySelector("pre[data-type='content']")) return;

        const header = ParagraphUtils.getHeaderElement(paragraph);
        const content = ParagraphUtils.getContentElement(paragraph);

        addVersioningButton(paragraph)
    });


});


// TODO: exit versioning and return to the last state
// Exit versioning mode
// const selector = document.liveQuerySelectorAll('.paragraph.fullscreen');
// selector.removed(FullscreenUtils.exitFullscreen);


// codestrate.addCommand("codestrates.cellVersioning", "Cell Versioning", (event) =&gt; {

//     console.log(event)

//     let paragraph;
//     if (event !== null &amp;&amp; event.target !== null) {
// 	let target = event.target;
//         paragraph = target.closest(".paragraph");
//     } else {
// 	// paragraph = codestrate.focussedParagraph;
//     }
//     // if (!paragraph) {
//     // 	paragraph = document.querySelector(".paragraph.fullscreen:not([transient-fullscreen='false']),.paragraph[transient-fullscreen='true']");
//     // }

//     if (paragraph) {
// 	// FullscreenUtils.togglePersistedFullscreen(paragraph);
//     }
// });

// codestrate.addKeyBinding("codestrates.cellVersioning", "ctrl+shift+v", true);

codestrate.addKeyBinding("codestrate.runCode", "ctrl+shift+enter", true);

</pre></div><div class="paragraph style-paragraph collapsed" data-id="CqSgXhhJ" name="Paragraph&nbsp;"><style data-type="content" type="text/css">html .paragraph .toggle-versioning-back-tiny,
html .paragraph .toggle-versioning-back-cardinal,
html .paragraph .toggle-versioning-forward-tiny, 
html .paragraph .toggle-versioning-forward-cardinal,
html .paragraph .toggle-versioning-mode,
html .paragraph .change-artefact {
    margin-left: 5px;
    margin-right: 10px;
}

html .paragraph .toggle-versioning-mode i:after {
	content: "change_history";
}

.v-active i:after {
	color: blue;
}

.v-active .failure i:after {
	color: red;
}


.versioning-v-number p {
 	  margin-top: 0.2em;
  	margin-right: 0.2em;
  	color: white;
}

.versioning-contributor p {
 	  margin-top: 0.2em;
  	margin-right: 1em;
  	color: white;
}

.default i:after {
  content: "rowing";
}

.changed-1 i:after {
  content: "bug_report";
}

.changed-2 i:after {
  content: "check_circle";
}

.changed-3 i:after {
  content: "account_circle";
}


html .paragraph .toggle-versioning-back-tiny i:after {
	content: "keyboard_arrow_right";
}

html .paragraph .toggle-versioning-back-cardinal i:after {
	content: "fast_forward";
}

html .paragraph .toggle-versioning-forward-tiny i:after {
	content: "keyboard_arrow_left";
}

html .paragraph .toggle-versioning-forward-cardinal i:after {
	content: "fast_rewind";
}
</style></div></div>