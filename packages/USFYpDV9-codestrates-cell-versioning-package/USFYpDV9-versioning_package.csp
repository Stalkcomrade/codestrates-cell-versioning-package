<div class="section section-visible" data-id="USFYpDV9" name="versioning package" data-type="package"><div class="paragraph body-paragraph" data-id="CiC6ZNKJ" name="Documentation"><div data-type="content" type="text/html" contenteditable="true" class="section-documentation"></div></div><div class="paragraph data-paragraph" data-id="NKRfAA7M" name="Properties"><pre data-type="content" type="application/json" class="section-properties">{
	"version"    : "0.3.2",
	"icon"       : "bubble_chart",
	"description": "a wrapper for core Webstrates api to enable local versioning for code chunks in Codestrates.",
	"tags"       : [
		              "function",
		              "code paragraphs"
	],
	"assets": [
	],
	"dependencies": [
	],
	"changelog":
	{
    "0.3.2" : "versioning UI only for code chunks, refactoring opsUtils into proper functions",
    "0.3"   : "added coreWebstrateClient API by Kristian Antonsen + helper utils for ops processing",
    "0.2.5" : "Updated UI, tested where it is actionable",
    "0.2"   : "Simple UI",
		"0.1"   : "Initial version."
	},
	"github": {
		"url"   : "https://github.com/Stalkcomrade/codestrates-cell-versioning-package",
		"folder": "packages/USFYpDV9-codestrates-cell-versioning-package"
	}
}</pre></div><div class="paragraph code-paragraph" data-id="zRmB9PSK" last-execution-state="success" name="helperFunctions"><pre data-type="content" type="text/javascript" id="helperFunctions">const compareArrays = (array1, array2) =&gt; {
    return array1.length === array2.length &amp;&amp; array1.every((value, index) =&gt; value === array2[index])
}


const FilterObjectByKey = (obj, key) =&gt; {
    return Object.keys(obj).reduce((acc, val) =&gt; {
        
        if (val !== key) {
            return  {
                ...acc,
                [val]: obj[val]
            }
        } else {
            return acc
        }
    }, {}) // INFO: first value for accumulator
}


const compareSort = (a, b) =&gt; {

    let comparison = 0;
    if (a.version &gt; b.version) {
        comparison = 1;
    } else if (a.version &lt; b.version) {
        comparison = -1;
    }
    return comparison;
}

exports = Object.assign(exports, {compareArrays, FilterObjectByKey, compareSort})</pre></div><div class="paragraph code-paragraph collapsed" data-id="3aj5B6jC" name="coreWebstratesClientAPI"><pre data-type="content" type="text/javascript" id="coreWebstratesClientAPI"> 
// coreEvents
const coreEventsModule = {};

// Map from event names to a set of the actual listeners: string -&gt; set of listeners.
const eventListeners = {};
// Map from event names to actual listeners: string -&gt; function.
const addEventListenerListeners = {};
// Map from event names to actual listeners: string -&gt; function.
const removeEventListenerListeners = {};

const priorities = {
	IMMEDIATE: 0,
	HIGH: 1,
	MEDIUM: 2,
	LOW: 3,
	LAST: 4
};

coreEventsModule.PRIORITY = new Proxy(priorities, {
	get: (target, name) =&gt; {
		if (name in target) return target[name];
		throw new Error(`Invalid priority ${name}`);
	}
});

/**
* Create new event.
* @param  {string}  eventName  Event name.
* @param  {object} options     An object of options:
*                              idempotent:      Whether we allow the same event to be created
*                                               multiple times without throwing an error.
*                              addListener:     A callback to be triggered when an eventListener
*                                               gets added.
*                              removeListener:  A callback to be triggered when an eventListener
*                                               gets added.

* @public
*/
coreEventsModule.createEvent = (eventName, options = {}) =&gt; {
	if (coreEventsModule.eventExists(eventName) &amp;&amp; !options.idempotent) {
		throw new Error(`Event ${eventName} already exists.`);
	}

	if (typeof options.addListener !== 'undefined') {
		if (typeof options.addListener !== 'function') {
			throw new Error(`addListener must be a function, received: ${options.addListener}.`);
		}
		addEventListenerListeners[eventName] = options.addListener;
	}

	if (typeof options.removeListener !== 'undefined') {
		if (typeof options.removeListener !== 'function') {
			throw new Error(`removeListener must be a function, received: ${options.removeListener}.`);
		}
		removeEventListenerListeners[eventName] = options.removeListener;
	}

	if (!eventListeners[eventName]) {
		eventListeners[eventName] = new Set();
	}
};

coreEventsModule.eventExists = (eventName) =&gt; eventListeners.hasOwnProperty(eventName);

coreEventsModule.addEventListener = (eventName, eventListener,
	priority = coreEventsModule.PRIORITY.LOW, options) =&gt; {

	eventListener.priority = priority;
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}

	if (eventListeners[eventName].has(eventListener)) {
		throw new Error(`EventListener already attacehd to ${eventName}.`);
	}
	eventListeners[eventName].add(eventListener);
	if (addEventListenerListeners[eventName]) {
		addEventListenerListeners[eventName](eventListener);
	}

};

coreEventsModule.removeEventListener = (eventName, eventListener) =&gt; {
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}
	eventListeners[eventName].delete(eventListener);
	if (removeEventListenerListeners[eventName]) {
		removeEventListenerListeners[eventName](eventListener);
	}
};

coreEventsModule.triggerEvent = (eventName, ...args) =&gt; {
	if (!coreEventsModule.eventExists(eventName)) {
		throw new Error(`Event ${eventName} doesn't exist.`);
	}

	// Convert set of event listeners to array, so we can sort them.
	const arrEventListeners = Array.from(eventListeners[eventName]);

	// Sort all events by priority (IMMEDIATE, HIGH, MEDIUM, ... ).
	arrEventListeners.sort((e, f) =&gt; e.priority - f.priority);

	// Execute events (in proper order).
	arrEventListeners.forEach(eventListener =&gt; {
		try {
			// IMMEDIATE listeners get triggered right now, everything else happens on the next tick.
			if (eventListener.priority === coreEventsModule.PRIORITY.IMMEDIATE) {
				eventListener(...args);
			} else {
				// It is somewhat counter-intuitive that non-IMMEDIATE listeners gets triggered by
				// setImmediate. setImmediate means "immediately after we're done with everything else".
				setImmediate(eventListener, ...args);
			}
		}
		catch (e) {
			console.error(e);
		}
	});
};

// module.exports = coreEventsModule;
////////////////////////////////////////////////////

// coreUtils

// JavaScript code here
// 'use strict';
const coreUtilsModule = {};

let locationObject;
/**
 * Parses a query string and returns a more friendly object.
 * @param  {Location} location Location object.
 * @return {object}            Object with webstrateId, tagOrVersion and parameters.
 */
coreUtilsModule.getLocationObject = () =&gt; {
	if (locationObject) {
		return locationObject;
	}

	const pathRegex = /^\/([A-Z0-9._-]+)\/(?:([A-Z0-9_-]+)\/)?/i.exec(window.location.pathname);
	const [ , webstrateId, tagOrVersion] = pathRegex;

	const parameters = {};
	const queryRegex =  /([^&amp;=]+)=?([^&amp;]*)/g;
	const query = window.location.search.substring(1);

	let match;
	while ((match = queryRegex.exec(query))) {
		const [, key, value] = match;
		parameters[key] = decodeURIComponent(value);
	}

	let tag, version;
	if (/^\d/.test(tagOrVersion) &amp;&amp; Number(tagOrVersion)) {
		version = Number(tagOrVersion);
	} else {
		tag = tagOrVersion;
	}

	locationObject = {
		webstrateId,
		staticMode: !!tagOrVersion,
		tagOrVersion,
		tag, version, // Only one of tag/version will be set
		parameters
	};

	return locationObject;
};

/**
 * Creates a throttled version of a function, i.e. one that only runs at most once every N
 * milliseconds.
 * @param  {Function} fn         Source function.
 * @param  {Number}   limit      Execution delay in milliseconds.
 * @return {Function}            Throttled source function.
 * @public
 */
coreUtilsModule.throttleFn = (fn, limit) =&gt; {
	let timeout, lastCall = 0;
	return function(...args) {
		let now = Date.now();
		let delay = lastCall + limit - now;
		if (delay &lt;= 0) {
			fn(...args);
			lastCall = now;
		} else {
			clearTimeout(timeout);
			timeout = setTimeout(() =&gt; {
				fn(...args);
				lastCall = now;
			}, delay);
		}
	};
};

/**
 * Checks for literal equality of objects. This is a stupid way, but it works.
 * @param  {obj} a First object to compare.
 * @param  {obj} b Second object to compare.
 * @return {bool}  True if objects are equal.
 * @public
 */
coreUtilsModule.objectEquals = (a, b) =&gt; JSON.stringify(a) === JSON.stringify(b);

/**
 * Shallow clones an object.
 * @param  {obj} obj Object to be copied.
 * @return {obj}     Shallow clone.
 * @public
 */
coreUtilsModule.objectClone = (obj) =&gt; Array.isArray(obj) ? obj.slice(0) : Object.assign({}, obj);

/**
 * Returns a locked, shallow clone of an object.
 * @param  {obj} obj Object to lock and clone.
 * @return {obj}     Cloned object.
 * @public
 */
coreUtilsModule.objectCloneAndLock = (obj) =&gt; Object.freeze(coreUtilsModule.objectClone(obj));

/**
 * Get random integer from interval [min, max). Unbiased and evenly distributed (or close to).
 * @param  {int} min Minimum number, inclusive.
 * @param  {int} max Maximum number, exclusive.
 * @return {int}     Random number in interval [min, max)
 * @public
 */
coreUtilsModule.random = (min, max) =&gt; {
	return Math.floor(min + Math.random() * (max - min));
};

/**
 * Get random string of size.
 * @param  {int}    size     Expected length of string (optional).
 * @param  {string} alphabet List of characters to be used in string (optional).
 * @return {string}          Generated string.
 * @public
 */
coreUtilsModule.randomString = (size = 8,
	// Does not include 0, O, o, 1, I, l for readability.
	alphabet = '23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ') =&gt; {
	const len = alphabet.length;
	let str = '';
	while (size--) {
		str += alphabet[coreUtilsModule.random(0, len)];
	}
	return str;
};

/**
 * Get child nodes of an element. If the element is a fragment, get the content's child nodes.
 * @param  {DOMElement} parentElement Element to get child nodes of.
 * @return {array}                    List of child nodes.
 */
coreUtilsModule.getChildNodes = function(parentElement) {
	// This will be the case for &lt;template&gt; tags.
	if (parentElement.content &amp;&amp; parentElement.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
		parentElement = parentElement.content;
	}
	return parentElement.childNodes;
};

/**
 * Traverses a node tree and applies a callback to each node.
 * @param {DOMNode}  node     Node tree to traverse.
 * @param {DOMNode}  parent   Initial parent node.
 * @param {Function} callback Callback.
 * @public
 */
coreUtilsModule.recursiveForEach = function(node, callback, parent = null) {
	callback(node, parent);

	Array.from(coreUtilsModule.getChildNodes(node)).forEach(child =&gt; {
		coreUtilsModule.recursiveForEach(child, callback, node);
	});
};

/**
 * Append a DOM element childElement to another DOM element parentElement. If the DOM element to
 * be appended is a script, prevent the execution of the script. If the parentElement is a
 * &lt;template&gt;, add the child to the parentElement's documentFragment instead. If a referenceNode
 * is specified, the element is inserted before the referenceNode.
 * @param {DOMNode} parentElement Parent element.
 * @param {DOMNode} childElement  Child element.
 * @param {DOMNode} referenceNode Node to insert before.
 * @public
 */
coreUtilsModule.appendChildWithoutScriptExecution = (parentElement, childElement, referenceNode) =&gt;
{
	// We just insert text nodes right away, we're only interested in doing fancy stuff with elements
	// that may have scripts as children.
	if (!(childElement instanceof HTMLElement)) {
		return parentElement.insertBefore(childElement, referenceNode || null);
	}

	// To prevent scripts from being executed when inserted, we use a little hack. Before inserting
	// the script, we replace the actual script with dummy content, causing that to be executed
	// instead of the actual script. If it's an inline script, we insert a script with dummy content
	// ('// Execution prevention'), and then replace the innerHTML afterwards.
	// To prevent issues with any other attributes (e.g. crossorigin and integrity), we also remove
	// all those attributes and insert them later.
	const scriptMap = new Map();
	const scripts = (childElement instanceof HTMLScriptElement) ? [ childElement ]
		: [ ...childElement.querySelectorAll('script') ];

	scripts.forEach(script =&gt; {
		const attrs = [];
		Array.from(script.attributes).forEach(attr =&gt; {
			attrs.push([ attr.nodeName, attr.nodeValue ]);
			script.removeAttribute(attr.nodeName);
		});
		const text = script.innerHTML;
		script.innerHTML = '// Execution prevention';
		scriptMap.set(script, [ attrs, text ]);
	});

	parentElement.insertBefore(childElement, referenceNode || null);

	scripts.forEach(script =&gt; {
		const [ attrs, text ] = scriptMap.get(script);
		attrs.forEach(attr =&gt; {
			const [nodeName, nodeValue] = attr;
			script.setAttribute(nodeName, nodeValue);
		});
		script.innerHTML = text;
	});
};

/**
 * Reinsert and execute an array of scripts in order.
 * @param {array}    scripts  Array of script DOM elements.
 * @param {Function} callback Function to call once all scripts have been executed.
 * @public
 */
coreUtilsModule.executeScripts = (scripts, callback) =&gt; {
	const script = scripts.shift();
	if (!script) {
		return callback();
	}

	// Scripts in templates shouldn't get executed. If we didn't do this, we could also run into
	// issues a little later in the function when we'd attempt to reinsert the element into its
	// parent if the script is a direct child of the template, as such children don't actually have
	// parents.
	if (coreUtilsModule.elementIsTemplateDescendant(script)) {
		return coreUtilsModule.executeScripts(scripts, callback);
	}

	const executeImmediately = !script.src;
	const newScript = document.createElementNS(script.namespaceURI, 'script');
	if (!executeImmediately) {
		newScript.onload = newScript.onerror = function() {
			coreUtilsModule.executeScripts(scripts, callback);
		};
	}

	// Copy over all attribtues.
	for (let i = 0; i &lt; script.attributes.length; i++) {
		const attr = script.attributes[i];
		newScript.setAttribute(attr.nodeName, attr.nodeValue);
	}

	// Copy over all other properties.
	Object.assign(newScript, script);

	// We're defining the wid with defineProperty to make it non-modifiable, but assign will just copy
	// over the value, leaving it modifiable otherwise.
	coreUtilsModule.setWidOnElement(newScript, script.__wid);

	newScript.innerHTML = script.innerHTML;

	script.parentElement.insertBefore(newScript, script);
	script.remove();

	if (executeImmediately) {
		coreUtilsModule.executeScripts(scripts, callback);
	}
};


/**
 * Check whether a DOM Node is a descendant of a template tag (or actually a documentFragment).
 * One might assume this could be done with `element.closest("template")`, but that won't be the
 * case, because a documentFragment technically isn't a parent (and also doesn't have any parent),
 * so there will be no tree to search upwards through after we reach the documentFragment.
 * @param  {DOMNode} DOMNode DOM Node to check.
 * @return {boolean}         True if the DOM Node is a descendant of a template.
 * @private
 */
coreUtilsModule.elementIsTemplateDescendant = element =&gt;
	document.documentElement.ownerDocument !== element.ownerDocument;

/**
 * Check if the current page has been transcluded (i.e. is an iframe)
 * @return {bool} True if this frame is transcluded.
 * @public
 */
coreUtilsModule.isTranscluded = () =&gt; window.frameElement &amp;&amp; window.parent !== window;

/**
 * Check whether the current frame shares domain with the outer frame. Only useful when called
 * when transcluded (i.e. called from an iframe). This is used to determine whether accessing the
 * outer frame will cause CORS errors.
 * @return {bool} True if current and outer frame share domain.
 * @public
 */
coreUtilsModule.sameParentDomain = () =&gt; {
	const a = document.createElement('a');
	a.href = document.referrer;
	return a.host === location.host;
};

/**
 * Removes characters that are illegal in attributes and tag names.
 * @param  {string} tagName Unsanitized string.
 * @return {string}         Sanitized string.
 * @public
 */
coreUtilsModule.sanitizeString = (string) =&gt; {
	// See https://www.w3.org/TR/html5/syntax.html#tag-name and
	// https://www.w3.org/TR/html5/syntax.html#elements-attributes
	// These regex test does not fully adhere to either, but is more stringent to avoid serialization
	// issues.
	var NAME_START_CHAR_REGEX = /:|[A-Z]|_|[a-z]/;
	var NAME_CHAR_REGEX = /-|\.|[0-9]/;

	return string.split('').map(function(char, index) {
		if (NAME_START_CHAR_REGEX.test(char) || (index &gt; 0 &amp;&amp; NAME_CHAR_REGEX.test(char))) {
			return char;
		}
		return '_';
	}).join('');
};

/**
 * Replaces ampersands (&amp;) and double-quotes (") with their respective HTML entities.
 * @param  {string} value Unescaped string.
 * @return {string}       Escaped string.
 * @public
 */
coreUtilsModule.escape = value =&gt; value &amp;&amp; value.replace(/&amp;/g, '&amp;amp;').replace(/"/g, '&amp;quot;');

/**
 * Replaces &amp;amp; and &amp;quot; with their respective characters (&amp; and ").
 * @param  {string} value Escaped string.
 * @return {string}       Unescaped string.
 * @public
 */
coreUtilsModule.unescape = value =&gt; value &amp;&amp; value.replace(/&amp;amp;/g, '&amp;').replace(/&amp;quot;/g, '"');

/**
 * Replaces "." with &amp;dot;.
 * @param  {string} value Unescaped string.
 * @return {string}       Escaped string.
 * @public
 */
coreUtilsModule.escapeDots = value =&gt; value &amp;&amp; value.replace(/\./g, '&amp;dot;');

/**
 * Replaces &amp;dot; with ".".
 * @param  {string} value Escaped string.
 * @return {string}       Unescaped string.
 * @public
 */
coreUtilsModule.unescapeDots = value =&gt; value &amp;&amp; value.replace(/&amp;dot;/g, '.');

const widMap = new Map();
/**
 * Add a wid to a node and make it (easily) non-modifiable.
 * @param  {DOMNode} node Node to set wid on.
 * @param  {string} wid  wid.
 * @public
 */
coreUtilsModule.setWidOnElement = (node, wid) =&gt; {
	widMap.set(wid, node);
	Object.defineProperty(node, '__wid', {
		value: wid,
		writable: false, // No overwriting
		enumerable: true, // Let iterators and Object.assign see the wid.
		configurable: true // Allow us to redefine it in rare race condition scenarios.
	});
};

/**
 * Remove element from wid map. Bye, bye, memory leak!
 * @param  {string} wid wid.
 * @public
 */
coreUtilsModule.removeWidFromElement = wid =&gt; widMap.delete(wid);

/**
 * Get element by wid.
 * @param  {string} wid wid.
 * @return {DOMNode}     DOM Element with given wid.
 * @public
 */
coreUtilsModule.getElementByWid = wid =&gt; widMap.get(wid);

// module.exports = coreUtilsModule;

////////////////////////////////////////

// INFO: corePathTree

// JavaScript code here
// const coreUtils = require('./coreUtils');
const coreUtils = coreUtilsModule;
/*
Webstrates PathTree (webstrates.pathree.js)

PathTree is a tree data structure mapping to the DOM, but with some extended attributes. Each node
in a PathTree consists of a unique id, a list of children, a parent, and the node's mapped DOM
element.

The primary purposes of the PathTree are to:
  1) Maintain a copy of the DOM tree's structure pre-mutation, so operations on the pre-mutation DOM
     tree can be rewritten to work on the post-mutation DOM tree.
  2) Facilitate lightweight creation of JsonML which is used when creating operations that are to be
     sent to the Webstrates server.
  3) Allow for verifying the integrity of the document by comparing every DOM node to its respective
     PathTree node.
*/

/**
 * Generate a unique identifier (UUID4).
 * @return {UUID}
 */
function generateUUID() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
		var r = Math.random() * 16 | 0;
		var v = c === 'x' ? r : (r &amp; 0x3) | 0x8;
		return v.toString(16);
	});
}

/**
 * Create a PathTree from a DOM element. If a parentPathTree is provided, the created
 * PathTree will be a subtree of the parent.
 * @param {DOMNode} DOMNode	DOMNode to create PathTree from.
 * @param {PathTree} parentPathTree	PathTree to add as parent.
 * @param {bool} overwrite	Whether existing PathTree on the DOMNode should be overwritten by the
 * new PathTree or just appended to it.
 * @return {PathTree} Created PathTree.
 */
function PathTree(DOMNode, parentPathTree, overwrite) {
	this.id = generateUUID();
	this.children = [];
	this.parent = parentPathTree;
	this.DOMNode = DOMNode;

	// When moving an element around, a node may exist in two places at once for a brief moment.
	// __pathNodes therefore has to be a list.
	if (overwrite || !DOMNode.__pathNodes || DOMNode.__pathNodes.length === 0) {
		DOMNode.__pathNodes = [this];
	} else {
		DOMNode.__pathNodes.push(this);
	}

	var childNodes = DOMNode.hasChildNodes() ? DOMNode.childNodes :
		(DOMNode.content &amp;&amp; DOMNode.content.childNodes) || [];
	Array.from(childNodes).forEach(function(childNode) {
		var childPathNode = PathTree.create(childNode, this, overwrite);
		if (childPathNode) {
			this.children.push(childPathNode);
		}
	}.bind(this));
}

/**
 * Check whether a DOM Node should be persisted on the server (i.e. whether it's transient or not).
 * For a DOM Node to be transient, it has to be an element (i.e. not a text node), exist outside of
 * a template tag, as well as not be in the list of transient elements (config.transientElements).
 * @param  {DOMNode} DOMNode DOM Node to check.
 * @return {boolean}         True if the DOM Node is transient.
 * @private
 */
function isTransientElement(DOMNode) {
	// Only elements can be transient
	return DOMNode.nodeType === document.ELEMENT_NODE
		// Nothing in templates can be transient
		&amp;&amp; !coreUtils.elementIsTemplateDescendant(DOMNode)
		// Only elements passing a function defined in config.isTransientElement are transient.
		&amp;&amp; config.isTransientElement &amp;&amp; config.isTransientElement(DOMNode);
}

/**
 * Add PathNode to node if the node isn't a &lt;transient&gt; element.
 * @param  {[type]} DOMNode        [description]
 * @param  {[type]} parentPathTree [description]
 * @param  {[type]} overwrite      [description]
 * @return {[type]}                [description]
 */
PathTree.create = function(DOMNode, parentPathTree, overwrite) {
	// Transient elements are not supposed to be persisted, and should thus not be part of the
	// PathTree. Unless the transient element is in a &lt;template&gt;.
	if (isTransientElement(DOMNode) || (!parentPathTree &amp;&amp; DOMNode !== document.documentElement)) {
		return;
	}

	return new PathTree(DOMNode, parentPathTree, overwrite);
};
/**
 * Creates a JsonML representation of the PathTree.
 * @return {JsonML} JsonML representation of PathTree.
 */
PathTree.prototype.toPath = function() {
	if (!this.parent) {
		return [];
	}

	var childIndex = this.parent.children.findIndex(function(sibling) {
		return sibling.id === this.id;
	}.bind(this));

	// In the JsonML representation, the list elements start at position 2 in the object:
	//   [tag-name, attributes, ...element-list]
	var ELEMENT_LIST_OFFSET = 2;
	return [...this.parent.toPath(), ELEMENT_LIST_OFFSET + childIndex];
};

/**
 * Remove a PathTree by removing itself from parent as well as removing all children.
 * @param {bool} shallow Does not remove itself from parent if true (deletion if shallow).
 * @return {PathTree}    The deleted PathTree, consisting only of an object with an id.
 */
PathTree.prototype.remove = function(shallow) {
	// TODO: Why can't we do this EVERY time? If we do this on the children as well, the integrity
	// check fails.
	if (!shallow) {
		// Remove ourselves from our parent.
		this.parent.children.splice(this.parent.children.indexOf(this), 1);
	}
	this.parent = null;

	// Remove ourselves from our DOMNode.
	this.DOMNode.__pathNodes.splice(this.DOMNode.__pathNodes.indexOf(this), 1);
	this.DOMNode = null;

	// Remove all our children.
	this.children.forEach(function(child) {
		child.remove(true);
	});
	this.children = null;
};

/**
 * Checks the integrity of the document by recursively comparing the elements of the PathTree to
 * that of the DOM node.
 * @return {Array of results}
 */
PathTree.prototype.check = function() {
	if (this.DOMNode.__pathNodes.length &gt; 1) {
		console.log(this.DOMNode, this.DOMNode.__pathNodes);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'Node has multiple paths';
	}

	var domNodePathNode = this.DOMNode.__pathNodes[0];
	if (domNodePathNode.id !== this.id) {
		console.log(this.DOMNode, this);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'No id match';
	}

	var definedChildNodesInDom = (function() {
		var ref, ref1;
		ref = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes
			: (this.DOMNode.content &amp;&amp; this.DOMNode.content.childNodes) || [];
		var results = [];
		for (var j = 0, len = ref.length; j &lt; len; j++) {
			var childNode = ref[j];
			if (((ref1 = childNode.__pathNodes) != null ? ref1.length : void 0) &gt; 0) {
				results.push(childNode);
			}
		}
		return results;
	}.bind(this))();

	if (definedChildNodesInDom.length !== this.children.length) {
		console.log(definedChildNodesInDom, this.children, this);
		window.alert('Webstrates has encountered an error. Please reload the page.');
		throw 'Different amount of children';
	}

	var childNodes = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes
		: (this.DOMNode.content &amp;&amp; this.DOMNode.content.childNodes) || [];
	childNodes = Array.from(childNodes).filter(function(childNode) {
		return !childNode.tagName || childNode.tagName.toLowerCase() !== 'transient'
			|| coreUtils.elementIsTemplateDescendant(childNode);
	});
	if (definedChildNodesInDom.length !== childNodes.length) {
		console.log(definedChildNodesInDom, childNodes);
		console.warn('Warning: Found zombie nodes in DOM.');
	}

	var results = [];
	for (var i = 0, j = 0, len = definedChildNodesInDom.length; j &lt; len; i = ++j) {
		results.push(this.children[i].check());
	}

	return results;
};

/**
 * Returns the last added pathNode of an element. If a parent DOM element is provided, we search
 * for the pathNode that matches on parent.
 * @param  {DOMNode} elem       Element to get pathNode of.
 * @param  {DOMNode} parentElem Parent of Element (optional).
 * @return {PathTree}           PathNode found or null.
 */
PathTree.getPathNode = function(elem, parentElem) {
	if (!elem || !elem.__pathNodes) {
		return null;
	}

	if (!parentElem || !parentElem.__pathNodes) {
		return elem.__pathNodes[elem.__pathNodes.length - 1];
	}

	var matchingElement = null;
	parentElem.__pathNodes.some(function(parentPathNode) {
		return (matchingElement = elem.__pathNodes.find(function(pathNode) {
			return pathNode.parent.id === parentPathNode.id;
		}));
	});

	return matchingElement;
};

var jsonml = {
	TAG_NAME_INDEX: 0,
	ATTRIBUTE_INDEX: 1,
	ELEMENT_LIST_OFFSET: 2
};


/**
 * Returns the DOM element at the end of the path.
 * @param  {HTMLElement|PathTree} parentElement The element used to nagivate to the path from. May
 *                                              be either a DOM element or a PathTree.
 * @param  {JsonMLPath} path                    Path to follow on parentElement.
 * @return {[DOMElement, int, DOMElement, int]} The DOM element found, including its index on its
 *                                              parent, the parent DOM element, as possibly a
 *                                              JsonML index in case the path doesn't at a DOM
 *                                              element (it may end at a tag name or attribute
 *                                              object).
 */
PathTree.elementAtPath = function(parentElement, path) {
    // debugger;
	var parentPathNode = parentElement instanceof PathTree ? parentElement
		: PathTree.getPathNode(parentElement);

	var jsonmlIndex = path[0];
	if (jsonmlIndex === jsonml.ATTRIBUTE_INDEX) {
		// An attribute's parent could arguably be the element it's defined on, so the childElement
		// and parentElement are the same. Therefore, there also can't be a childIndex.
		return [parentElement, undefined, parentElement, jsonmlIndex];
	}

	var childIndex = jsonmlIndex - jsonml.ELEMENT_LIST_OFFSET;
	var childPathNode = parentPathNode &amp;&amp; parentPathNode.children[childIndex];

	var nextJsonmlIndex = path[1];
	if (path.length === 1
		|| nextJsonmlIndex === jsonml.TAG_NAME_INDEX
		|| nextJsonmlIndex === jsonml.ATTRIBUTE_INDEX) {
		var childElement = childPathNode &amp;&amp; childPathNode.DOMNode;
		parentElement = parentPathNode.DOMNode;
		return [childElement, childIndex, parentElement, nextJsonmlIndex];
	}
	return PathTree.elementAtPath(childPathNode, path.slice(1));
};

////////////////////////

// console.log(PathTree.elementAtPath(document.getElementsByName("idVersion")[0].__pathNodes[0].children[0].children[0].toPath(), [1,37]))

// console.log(PathTree.elementAtPath(document.body, [3,5,33,2,2,2,37]))


///////////////////////

// console.log(PathTree.getPathNode(document.getElementById("coreMutation"), document.body))
// console.log(PathTree.elementAtPath(document.children[0].__pathNodes[0].DOMNode, [1, 5, 33, 2, 2, 2, 37]))
// console.log(PathTree.elementAtPath(document.children[0].__pathNodes[0].DOMNode, [1, 5, 33, 2, 2, 2, 37]))
// console.log(PathTree.getPathNode(document.getElementsByName("coreMutation")[0]))

// console.log(PathTree.getPathNode(document.getElementsByName("idVersion")[0].children[1].__pathNodes[0].children[0].DOMNode))
// console.log(PathTree.getPathNode(document.getElementById("idVersion"), document.body).toPath());

// console.log(document.getElementsByName("coreMutation")[0].__pathNodes[0].toPath());
// console.log(document.getElementsByName("idVersion")[0].__pathNodes[0].toPath());

// module.exports = PathTree;

////////////////////////////////////////////////////

// INFO: coreMutation


// JavaScript code here
// var coreEvents = require('./coreEvents');
// const coreUtils = require('./coreUtils');
// const coreUtils = coreUtilsModule;

var coreEvents = coreEventsModule;
    
const coreMutation = {};

coreEvents.createEvent('mutation');

const observerOptions = {
	childList: true,
	subtree: true,
	attributes: true,
	characterData: true,
	attributeOldValue: true,
	characterDataOldValue: true
};

let rootElement;
const primaryObserver = new MutationObserver(mutationsHandler);
const fragmentObservers = {};
const fragmentParentMap = {};

coreMutation.emitMutationsFrom = (_rootElement) =&gt; {
	rootElement = _rootElement;
	// Add MutationObserver on root.
	primaryObserver.observe(rootElement, observerOptions);
	// Add MutationObservers on to all documentFragments (the things that live inside &lt;template&gt;s).
	coreUtils.recursiveForEach(rootElement, (node) =&gt; {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			setupFragmentObserver(node.content, node);
		}
	});
	isPaused = false;
};

function mutationsHandler(mutations) {
	mutations.forEach(function forEachMutation(mutation) {
		// DocumentFragments (as per the specification) can't have parents, even if they actually do.
		// Therefore, they also can't exist in the PathTree. Instead, we pretend that they *are*
		// their parents. Since this is only used with &lt;template&gt;s, whose only children are a single
		// documentFragment, this makes sense. The JsonML also does not store the documentFragment,
		// but it is automatically created when creating a &lt;template&gt; tag.
		if (mutation.target.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			// We use defineProperty rather than a primitive assignemtn, because the target property is
			// read-only.
			Object.defineProperty(mutation, 'target', {
				value: fragmentParentMap[mutation.target.id]
			});
		}

		coreEvents.triggerEvent('mutation', mutation);
	});
}

/**
 * Set ups a Mutation Observer on a Document Fragment.
 * @param {DocumentFragment} fragment Fragment to observe.
 * @param {DOMElement} element        Element containing fragment.
 * @private
 */
function setupFragmentObserver(fragment, element) {
	if (fragment.id) {
		return;
	}
	fragment.id = coreUtils.randomString();
	const fragmentObserver = new MutationObserver(mutationsHandler);
	fragmentObserver.observe(fragment, observerOptions);
	fragmentObservers[fragment.id] = [fragment, fragmentObserver];
	fragmentParentMap[fragment.id] = element;
}

/**
 * Removes a Mutation Observer from a Document Fragment.
 * @param {DocumentFragment} fragment Fragment to remove observer from.
 * @private
 */
function teardownFragmentObserver(fragment) {
	if (!fragment.id || !fragmentParentMap[fragment.id]) {
		return;
	}
	let fragmentObserver;
	[fragment, fragmentObserver] = fragmentObservers[fragment.id];
	fragmentObserver.disconnect();
	delete fragmentObservers[fragment.id];
	delete fragmentParentMap[fragment.id];
}

// The global mutation observer does not observe on changes to documentFragments (the things that
// live inside &lt;template&gt;s within the document, so we have to manually create and manage individual
// observers for each documentFragment.
// Before we can do that, we have to create DOMNodeInserted and DOMNodeDeletedoutselves ourselves,
// because this module gets loaded before they get created (by coreOpApplier or coreOpCreator).
// The 'idempotent' option allows these events to be created even if they already. Just to be safe.
coreEvents.createEvent('DOMNodeInserted', { idempotent: true });
coreEvents.createEvent('DOMNodeDeleted', { idempotent: true });

// Whenever the DOM gets modified, we add/remove potential MutationObservers from documentFragments
// (i.e. the things living inside &lt;template&gt;s).
coreEvents.addEventListener('DOMNodeInserted', addedNode =&gt; {
	coreUtils.recursiveForEach(addedNode, (node) =&gt; {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			setupFragmentObserver(node.content, node);
		}
	});
}, coreEvents.PRIORITY.IMMEDIATE);

coreEvents.addEventListener('DOMNodeDeleted', removedNode =&gt; {
	coreUtils.recursiveForEach(removedNode, function(node) {
		if (node.content &amp;&amp; node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			teardownFragmentObserver(node.content);
		}
	});
}, coreEvents.PRIORITY.IMMEDIATE);

// To not create a live-lock, the coreOpApplier module needs to pause the mutation observer when
// adding incoming ops to the DOM. Otherwise, those incoming ops would in turn create new ops, and
// so on.
// The following allows other modules to manage the MutationObservers.
let isPaused = true;
Object.defineProperty(coreMutation, 'isPaused', {
	get: () =&gt; isPaused
});


coreMutation.pause = () =&gt; {
	if (isPaused) return;
	Object.keys(fragmentObservers).forEach(function(fragmentId) {
		var [_fragment, fragmentObserver] = fragmentObservers[fragmentId];
		fragmentObserver.disconnect();
	});
	primaryObserver.disconnect();
	isPaused = true;
};

coreMutation.resume = () =&gt; {
	if (!isPaused) return;
	Object.keys(fragmentObservers).forEach(function(fragmentId) {
		var [fragment, fragmentObserver] = fragmentObservers[fragmentId];
		fragmentObserver.observe(fragment, observerOptions);
	});
	primaryObserver.observe(rootElement, observerOptions);
	isPaused = false;
};

// module.exports = coreMutation;

////////////////////////////////////////////////

// coreDOM

// JavaScript code here
// 'use strict';
/**
 * This modules allows other modules a more convenient way of overriding certain document
 * properties, specifically by preventing accidental infinite recursive calls and scope-binding
 * issues. On top of that, it allows modules  to override certain properties only internally, i.e.
 * so other modules will use some overriden property (e.g. document.createElement), while code
 * written in userland still will use the "regular" document.createElement.
 *
 * This module was particularly written to be used with protected mode, so elements created by
 * other modules automatically will be pre-approved while elements created in userland will not.
 */

// Directives to ESLint, so it'll allow us to use documentProxyObj and _document, which appears to
// be undefined, as they rather unorthodoxly is defined in wrapper-header.js. Also prevent ESLint
// from complaining that documentProxyObj is never used.
/* global _document documentProxyObj */
/* exported documentProxyObj */

const coreDOMModule = {};

// This object should be passed in as the last parameter by all other modules to Element
// prototype methods, so all modules can detect when a call to one of these comes from another
// module rather than from userland. It would be better to override the Element object like we
// override the document object, but it seems to be impossible to do this meaningfully.
coreDOMModule.elementOptions = {};

coreDOMModule.internalDocument = document;
// coreDOMModule.externalDocument = _document;
coreDOMModule.externalDocument = documentProxyObj;

const contexts = {
	INTERNAL: 0,
	BOTH: 1
};

coreDOMModule.CONTEXT = new Proxy(contexts, {
	get: (target, name) =&gt; {
		if (name in target) return target[name];
		throw new Error(`Invalid context ${name}, must be INTERNAL or BOTH`);
	}
});

const internalDocumentOverrides = new Map();


/**
 * Override a property on the document object, either internally or internally and externally.
 * @param  {string} property Name of property to override on document.
 * @param  {enum} context    Context, either CONTEXT.INTERNAL or CONTEXT.BOTH.
 * @param  {any} value       Any value.
 * @public
 */
coreDOMModule.overrideDocument = (property, context, value) =&gt; {
	// If the user is trying to override a property on the internal document, we save the property to
	// a map, so we can find it when it's being requested on the proxy document. If we did a
	// 'primitive' override on the document object, the override would also be active
	if (context === coreDOMModule.CONTEXT.INTERNAL) {
		if (internalDocumentOverrides.has(property))
			throw new Error('Property has already been overriden');

		return internalDocumentOverrides.set(property, value);
	}

	if (context === coreDOMModule.CONTEXT.BOTH) {
		if (typeof value === 'function') {
			// If the requested value is a function, bind the document's context to it and bind the
			// original function as the first argument. This, for instance, allows somebody to override
			// document.createElement and still have access to the original createElement function from
			// within the new implementation.
			const originalProperty = coreDOMModule.externalDocument[property]
				.bind(coreDOMModule.externalDocument);
			coreDOMModule.externalDocument[property] = value.bind(coreDOMModule.externalDocument,
				originalProperty);
		} else {
			coreDOMModule.externalDocument[property] = value;
		}
		return;
	}

	throw new Error('Invalid context', context);
};

/**
 * Proxy object for document. The proxy is actually defined in wrapper-header.js using an empty
 * object (documentProxyObj), which we now override with our own get trap.
 * @param  {Object} obj  Object the property is to be accessed on. Will always be document.
 * @param  {string} prop Name of property.
 * @return {mixed}       The property's value. Can be anything.
 */
documentProxyObj.get = (obj, prop) =&gt; {
	if (prop === 'PROXY_DOCUMENT') return true;

	if (internalDocumentOverrides.has(prop)) {
		// If the requested value is a function, bind the document's context to it and bind the
		// original function as the first argument. This, for instance, allows somebody to override
		// document.createElement and still have access to the original createElement function from
		// within the new implementation.
		return typeof internalDocumentOverrides.get(prop) === 'function'
			? internalDocumentOverrides.get(prop).bind(obj, coreDOMModule.externalDocument[prop])
			: internalDocumentOverrides.get(prop);
	}

	// If the requested value is a function, bind the document's context to it.
	return typeof obj[prop] === 'function'
		? obj[prop].bind(obj)
		: obj[prop];
};

// module.exports = coreDOMModule;

/////////////////////////////////////////////////////////////////////////////

// INFO: coreJsonML

// JavaScript code here
// 'use strict';
/* JsonML &lt;-&gt; HTML library by Kristian B. Antonsen
 * This library is based on jQuery JSONML Plugin by Trevor Norris.
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 */
// const coreUtils = require('./coreUtils');
// const coreDOM = require('./coreDOM');

// const coreUtils = coreUtilsModule;
const coreDOM = coreDOMModule;


const coreJsonML = {};

function isPlainObject(obj) {
	return obj &amp;&amp; typeof obj === 'object'
	// Previously, we did comparison like: Object.getPrototypeOf(obj) === Object.prototype, but we
	// can no longer do that, because if we use the parent's ShareDB Connection, plain objects created
	// in the outer frame will have used that frame's Object.prototype, which is not the same as the
	// Object.prototype in the inner frame, even though they're identical. Basically:
	// window.Object !== iframe.contentWindow.Object.
	&amp;&amp; Object.prototype.toString.call(obj) === '[object Object]';
}

function toHTML(elem, xmlNs, scripts) {
	const fragment = document.createDocumentFragment();
	let i = 0;
	let name = null;
	let selector;

	// Check if is an element or array of elements
	if (typeof elem[0] == 'string') {
		name = elem[0];
		i = 1;
	}

	if (elem[0] === '!' || elem[0] === '#comment') {
		return document.createComment(elem.slice(typeof elem[1] === 'string' ? 1 : 2).join(''));
	}

	for (; i &lt; elem.length; i++) {
		// If array create new element
		if (Array.isArray(elem[i])) {
			// children of foreignobject element should use the default XHTML namespace
			// ('http://www.w3.org/1999/xhtml'), so we set it to undefined. Curiously enough, if we
			// actually do `xmlNs = "http://www.w3.org/1999/xhtml"`, stuff won't be rendered properly.
			if (name.toLowerCase() === 'foreignobject') {
				xmlNs = undefined;
			}

			fragment.appendChild(toHTML(elem[i], xmlNs, scripts));

			// If object set element attributes
		} else if (isPlainObject(elem[i])) {
			if (name) {

				name = coreUtils.sanitizeString(name);

				// When loading a website with an SVG element without a namespace attribute, Chrome will
				// guess the namespace itself. When adding it like we do with Webstrates, it won't. So
				// to have Webstrates give us a more normal browser experience, we add the namespace
				// manually.
				if (name.toLowerCase() === 'svg') {
					xmlNs = 'http://www.w3.org/2000/svg';
				}

				// As also mentioned in regards to foreignobject, setting the namspace to the default
				// ("http://www.w3.org/1999/xhtml") causes stuff to not render properly.
				if (xmlNs &amp;&amp; xmlNs !== 'http://www.w3.org/1999/xhtml') {
					selector = document.createElementNS(xmlNs, name);
				} else {
					selector = document.createElement(name);
				}

				// Add attributes to the element.
				for (let index in elem[i]) {
					// The __wid attribute is a unique ID assigned each node and should not be in the DOM, but
					// instead be a property on the DOM element.
					if (index.toLowerCase() === '__wid') {
						coreUtils.setWidOnElement(selector, elem[i][index]);
						continue;
					}
					const value = coreUtils.unescape(elem[i][index]);
					index = coreUtils.sanitizeString(index);
					if (xmlNs === 'http://www.w3.org/2000/svg') {
						if (index === 'href' || index === 'xlink:href') {
							selector.setAttributeNS('http://www.w3.org/1999/xlink', index, value,
								coreDOM.elementOptions);
						}
					}
					const isSvgPath = selector.tagName.toLowerCase() === 'path' &amp;&amp; index === 'd';
					if (isSvgPath) {
						selector.__d = value;
					}
					selector.setAttribute(coreUtils.unescapeDots(index), value, coreDOM.elementOptions);
				}

				// Add scripts to our scripts list, so we can execute them later synchronously.
				if (selector.tagName.toLowerCase() === 'script') {
					selector.async = false;
					scripts &amp;&amp; scripts.push(selector);
				}
			}

			// If string or number insert text node
		} else if (typeof elem[i] == 'number' || typeof elem[i] == 'string') {
			fragment.appendChild(document.createTextNode(elem[i]));

			// If is an element append to fragment
		} else if (elem[i].nodeType) {
			fragment.appendChild(elem[i]);
		}
	}

	if (!selector &amp;&amp; name) {
		name = coreUtils.sanitizeString(name);
		selector = document.createElement(name);
	}

	// If a selector is set append children and return
	if (selector) {
		// When creating &lt;templates&gt;, we need the document to actually contain an documentFragment.
		// If we just add a documentFragment to an element, the children of documentFragment will
		// actually be added instead. To prevent this, we add the children to the `content` property
		// if it exists.
		if (selector.content &amp;&amp; selector.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
			selector.content.appendChild(fragment);
		} else {
			selector.appendChild(fragment);
		}
		return selector;
	}

	// Otherwise return children of fragment
	return fragment.childNodes;
}

coreJsonML.toHTML = toHTML;

function addChildren(/*DOM*/ elem, /*function*/ filter, /*JsonML*/ jml) {
	const childNodes = coreUtils.getChildNodes(elem);
	if (childNodes.length === 0) return false;

	for (let i=0; i&lt;childNodes.length; i++) {
		const child = fromHTML(childNodes[i], filter);
		if (child) {
			jml.push(child);
		}
	}

	return true;
}

/**
 * @param {Node} elem
 * @param {function} filter
 * @return {array} JsonML
 */
function fromHTML(elem, filter) {
	// If an element doesn't have a PathTree, we don't want it in the JsonML. This will be the case
	// for &lt;transient&gt; elements.
	if (!elem || !elem.nodeType || !elem.__pathNodes || elem.__pathNodes.length === 0) {
		// free references
		return (elem = null);
	}

	let i, jml;
	switch (elem.nodeType) {
		case document.ELEMENT_NODE:
		case document.DOCUMENT_NODE:
		case document.DOCUMENT_FRAGMENT_NODE: {
			jml = [elem.tagName||''];

			const attr = elem.attributes;
			let props = {};
			let hasAttrib = false;

			for (i=0; attr &amp;&amp; i&lt;attr.length; i++) {
				// Transient attributes should not be added to the JsonML.
				if (config.isTransientAttribute(elem, attr[i].name)) {
					continue;
				}
				if (attr[i].specified) {
					if (attr[i].name === 'style') {
						props.style = elem.style.cssText || attr[i].value;
					} else if ('string' === typeof attr[i].value) {
						if (elem.namespaceURI === 'http://www.w3.org/2000/svg') {
							props[attr[i].name.toLowerCase()] = attr[i].value;
						} else {
							props[attr[i].name] = attr[i].value;
						}
					}
					hasAttrib = true;
				}
			}

			if (elem.__wid) {
				props.__wid = elem.__wid;
				hasAttrib = true;
			}

			jml.push(props); //Webstrates always assumes that an element has attributes.

			let child, childNodes;
			switch (jml[0].toLowerCase()) {
				case 'frame':
				case 'iframe':
					break; //Do not recursively serialize content in iFrames (CNK)
				case 'style':
					child = elem.styleSheet &amp;&amp; elem.styleSheet.cssText;
					if (child &amp;&amp; 'string' === typeof child) {
						// unwrap comment blocks
						child = child.replace('&lt;!--', '').replace('--&gt;', '');
						jml.push(child);
					} else if ((childNodes = coreUtils.getChildNodes(elem))) {
						for (i=0; i&lt;childNodes.length; i++) {
							child = childNodes[i];
							child = fromHTML(child, filter);
							if (child &amp;&amp; 'string' === typeof child) {
								// unwrap comment blocks
								child = child.replace('&lt;!--', '').replace('--&gt;', '');
								jml.push(child);
							}
						}
					}
					break;
				case 'input':
					addChildren(elem, filter, jml);
					child = (elem.type !== 'password') &amp;&amp; elem.value;
					if (child) {
						if (!hasAttrib) {
							// need to add an attribute object
							jml.shift();
							props = {};
							jml.unshift(props);
							jml.unshift(elem.tagName||'');
						}
						props.value = child;
					}
					break;
				case 'textarea':
					if (!addChildren(elem, filter, jml)) {
						child = elem.value || elem.innerHTML;
						if (child &amp;&amp; 'string' === typeof child) {
							jml.push(child);
						}
					}
					break;
				default:
					addChildren(elem, filter, jml);
					break;
			}

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}

			// free references
			elem = null;
			return jml;
		}
		case Node.TEXT_NODE: // text node
		case Node.CDATA_SECTION_NODE: { // CDATA node
			const str = String(elem.nodeValue);
			// free references
			elem = null;
			return str;
		}
		case Node.DOCUMENT_TYPE_NODE: { // doctype
			jml = ['!'];

			const type = ['DOCTYPE', (elem.name || 'html').toLowerCase()];

			if (elem.publicId) {
				type.push('PUBLIC', '"' + elem.publicId + '"');
			}

			if (elem.systemId) {
				type.push('"' + elem.systemId + '"');
			}

			jml.push(type.join(' '));

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}
			// free references
			elem = null;
			return jml;
		}
		case Node.COMMENT_NODE: { // comment node
			if ((elem.nodeValue||'').indexOf('DOCTYPE') !== -1) {
			// free references
				elem = null;
				return null;
			}

			jml = ['!',
				elem.nodeValue];

			// filter result
			if ('function' === typeof filter) {
				jml = filter(jml, elem);
			}

			// free references
			elem = null;
			return jml;
		}
		default: { // etc.
			// free references
			return (elem = null);
		}
	}
}

coreJsonML.fromHTML = fromHTML;

// module.exports = coreJsonML;

// INFO: coreOpApplier

/*
Webstrates ApplyOp (coreOpApplier.js)

This module exposes the applyOp(op, rootElement) function on the Webstrates scope. This function
applies a subset of json0 OT operations (see https://github.com/ottypes/json0) to a DOM element.
The operations handled are list insertion and deletion (li and ld), as well as string insertion and
deletion (si and sd). These operations are generated on another client using the CreateOp module.
*/
// const coreEvents = require('./coreEvents');
// const coreUtils = require('./coreUtils');
// const corePathTree = require('./corePathTree');
// const coreMutation = require('./coreMutation');
// const coreJsonML = require('./coreJsonML');
// const coreDOM = require('./coreDOM');

// const coreEvents = coreEventsModule;
// const coreUtils = coreUtilsModule;
// const coreDOM = coreDOMModule;

// const jsonml = {
// 	TAG_NAME_INDEX: 0,
// 	ATTRIBUTE_INDEX: 1,
// 	ELEMENT_LIST_OFFSET: 2
// };

const corePathTree = PathTree;
// const coreMutation = coreMutation;
const coreJsonMLModule = coreJsonML;



const coreOpApplier = {};

// The 'idempotent' option allows these events to be created even if they already
// exists. We do this, because these events also are used (and created) in coreOpCreator.
coreEvents.createEvent('DOMAttributeSet', { idempotent: true });
coreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });
coreEvents.createEvent('DOMNodeInserted', { idempotent: true });
coreEvents.createEvent('DOMNodeDeleted', { idempotent: true });
coreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });
coreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });
coreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });
coreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });



/**
 * Extract the XML namespace from a DOM element.
 * @param  {DOMNode} element Element.
 * @return {string}          Namespace string.
 * @private
 */
function getNamespace(element) {
	if (!element || !element.getAttribute) {
		return undefined;
	}

	if (element.closest('foreignObject') &amp;&amp; !(element instanceof SVGForeignObjectElement)) {
		return document.body.namespaceURI;
	}

	return element.getAttribute('xmlns') ? element.getAttribute('xmlns') : element.namespaceURI;
}

/**
 * Recursively navigates an element using path to set the value as an attribute.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode. Last element of path is the attribute
 *                                key.
 * @param {string} value          Attribute value.
 * @private
 */
function setAttribute(rootElement, path, cleanAttributeName, newValue) {
	const [childElement] = corePathTree.elementAtPath(rootElement, path);

	// This has been commented out as it makes non-transient attributes appear transient in protected
	// mode, and we don't really seem to need it. If an op comes in, it can't really be transient
	// after all.
	//if (config.isTransientAttribute(childElement, cleanAttributeName)) {
	//	return;
	//}

	// The __wid attribute is a unique ID assigned each node and should not be in the DOM.
	if (cleanAttributeName === '__wid') {
		coreUtils.setWidOnElement(childElement, newValue);
		return;
	}

	// MongoDB doesn't support periods (.) inkeys, so we store them as &amp;dot; instead.
	const attributeName = coreUtils.unescapeDots(cleanAttributeName);
	newValue = coreUtils.unescape(newValue);

	const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
	if (isSvgPath) childElement.__d = newValue;

	const oldValue = childElement.getAttribute(attributeName);
	childElement.setAttribute(attributeName, newValue, coreDOM.elementOptions);

	// Last argument is false for not local, i.e happened on another client.
	coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
		false);
}

/**
 * Recursively navigates an element using path to remove the attribute at the end of the path.
 * @param {DOMNode} rootElement   DOMNode usf ed as root element for path navigation.
 * @param {DOMPath} path          Path to fllow on DOMNode. Last element of path is the attribute
 *                                key.
 * @private
 */
function removeAttribute(rootElement, path, attributeName) {
	const [childElement ] = corePathTree.elementAtPath(rootElement, path);

	if (config.isTransientAttribute(childElement, attributeName)) {
		return;
	}

	const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
	if (isSvgPath) delete childElement.__d;
	const oldValue = childElement.getAttribute(attributeName);
	childElement.removeAttribute(attributeName);

	// Last argument is false for not local, i.e happened on another client.
	coreEvents.triggerEvent('DOMAttributeRemoved', childElement, attributeName, oldValue, false);
}

/**
 * Recursively navigates an element using path to insert an element.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {mixed} value           Element to insert, either a text string or JSON element.
 * @private
 */
function insertNode(rootElement, path, value) {
	const [childElement, childIndex, parentElement] =
		corePathTree.elementAtPath(rootElement, path);

	const namespace = getNamespace(parentElement);
	const newElement = typeof value === 'string' ?
		document.createTextNode(value) : coreJsonML.toHTML(value, namespace);

	// childElement may be undefined, and if so we insert newElement at the end of the list. If
	// chidElement is defined, however, we insert the element before childElement.
	coreUtils.appendChildWithoutScriptExecution(parentElement, newElement, childElement);

	const parentPathNode = corePathTree.getPathNode(parentElement);
	const childPathNode = corePathTree.create(newElement, parentPathNode);

	// childPathNode may not have been created, because its parent doesn't have a PathTree (because
	// its a descendant of a transient element, or a transient element itself) or because the new
	// element itself is a transient element.
	if (childPathNode) {
		// Insert new element into parent PathTree.
		parentPathNode.children.splice(childIndex, 0, childPathNode);
	}

	coreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);
}

/**
 * Recursively navigates an element using path to delete an element.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @private
 */
function deleteNode(rootElement, path) {
	const [childElement, childIndex, parentElement] =
		corePathTree.elementAtPath(rootElement, path);

	// This part is a bit of a hack, because contenteditable is a weird beast to play with.
	// Consider a contenteditable field with the text HELLO in it. Say user A puts a cursor before
	// the letter O: HELL|O. User B then makes a linebreak after the H. Now, ELLO gets removed,
	// setting user A's cursor after the H|, and then the ELLO part gets reinserted in a DIV element
	// below. Now the cursor is after H: H|, and not before the O as before: ELL|O.
	// To fix this issue, when something gets deleted, we try to find the next close text node, see
	// if its contents matches what we just removed, and if so, we set our cursor there, because it's
	// likely that this deletion was caused by the scenario just described.
	const fakeRange = getSelectionRange(childElement);
	let nextTextNode;
	// A text node directly after us.
	if (childElement.nextSibling &amp;&amp; childElement.nextSibling.nodeType === document.TEXT_NODE) {
		nextTextNode = childElement.nextSibling;
	// A text node in an element right after us.
	} else if (childElement.nextElementSibling &amp;&amp; childElement.nextElementSibling.firstChild
		&amp;&amp; childElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {
		nextTextNode = childElement.nextElementSibling.firstChild;
	// A text node right after our parent (if we're in a DIV for instance).
	} else if (parentElement.nextSibling
		&amp;&amp; parentElement.nextSibling.nodeType === document.TEXT_NODE) {
		nextTextNode = parentElement.nextSibling;
	// A text node in a DIV right after our parent (if we're in a DIV for instance).
	} else if (parentElement.nextElementSibling &amp;&amp; parentElement.nextElementSibling.firstChild
		&amp;&amp; parentElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {
		nextTextNode = parentElement.nextElementSibling.firstChild;
	}

	if (fakeRange &amp;&amp; childElement.data &amp;&amp; nextTextNode &amp;&amp; nextTextNode.data === childElement.data) {
		if (fakeRange.startContainer === childElement) {
			fakeRange.startContainer = nextTextNode;
		}
		if (fakeRange.endContainer === childElement) {
			fakeRange.endContainer = nextTextNode;
		}
		setSelectionRange(nextTextNode, fakeRange);
	}

	// Update PathTree to reflect the deletion.
	// TODO: Use PathTree.remove() instead.
	const parentPathNode = corePathTree.getPathNode(parentElement);
	//const childPathNode = corePathTree.getPathNode(childElement, parentPathNode);
	parentPathNode.children.splice(childIndex, 1);

	// And remove the actual DOM node.
	childElement.remove();

	// Notify nodeRemoved listeners.
	coreEvents.triggerEvent('DOMNodeDeleted', childElement, parentElement, false);
}

/**
 * Replace a node, either a tag name, list of attributes or a regular node.
 * Note that this is added for compatibility with a wider array of json0 operations such as those
 * used by Webstrates file system. Webstrates itself does not create these kinds of operations.
 * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {mixed} value           Element to insert, new tag name, or new set of attributes.
 * @private
 */
function replaceNode(rootElement, path, value) {
	const [childElement, childIndex, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);

	// Webstrates file system has some broken parsing, so it may think JavaScript like "&lt; b)" in
	// "if (a &lt; b)" is an element and try to send a replacement op. In this case, childElement
	// doesn't exist. This should be solved in Webstrates file system, but we'll fix it here, too.
	if (!childElement) {
		return;
	}

	switch (indexType) {
	// We're renaming a tag, e.g. when &lt;span&gt;foo&lt;/span&gt; should become &lt;div&gt;foo&lt;/div&gt;.
		case jsonml.TAG_NAME_INDEX: {
			const oldElement = childElement;
			const namespace = getNamespace(oldElement);
			const newElement = coreJsonML.toHTML([value], namespace);

			const parentPathNode = corePathTree.getPathNode(parentElement);
			if (!parentPathNode) {
				console.warn('No parentPathNode found, aborting. This shouldn\'t happen, but...');
				return;
			}
			// Move all children.
			while (oldElement.firstChild) {
				coreUtils.appendChildWithoutScriptExecution(newElement, oldElement.firstChild);
			}

			// Copy all attributes.
			for (let i = 0; i &lt; oldElement.attributes.length; i++) {
				const attr = oldElement.attributes.item(i);
				const attributeName = attr.nodeName;
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				if (isSvgPath) newElement.__d = attr.nodeValue;
				newElement.setAttribute(attributeName, attr.nodeValue);
			}

			// Overwrite old node with new node.
			coreUtils.appendChildWithoutScriptExecution(parentElement, newElement, oldElement);
			oldElement.remove();

			const newElementPathNode = corePathTree.create(newElement, parentPathNode, true);

			// New element may not have a PathNode if it's a transient object.
			if (!newElementPathNode) {
				break;
			}

			parentPathNode.children.splice(childIndex, 1, newElementPathNode);

			coreEvents.triggerEvent('DOMNodeDeleted', oldElement, parentElement, false);
			coreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);
			break;
		}
		// We're replacing an entire object of attributes by writing all the new attributes and
		// deleting old ones.
		case jsonml.ATTRIBUTE_INDEX: {
			const newAttributes = value;
			const oldAttributeKeys = Array.from(childElement.attributes).map(function(attribute) {
				return attribute.name;
			});

			const attributes = new Set([...Object.keys(newAttributes), ...oldAttributeKeys]);
			attributes.forEach(function(attributeName) {
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				if (attributeName in newAttributes) {
					if (isSvgPath) childElement.__d = newAttributes[attributeName];
					childElement.setAttribute(attributeName, newAttributes[attributeName]);
				} else {
					if (isSvgPath) delete childElement.__d;
					childElement.removeAttribute(attributeName);
				}
			});
			break;
		}
		// Otherwise, we're just replacing a regular node.
		default: {
			deleteNode(rootElement, path);
			insertNode(rootElement, path, value);
			break;
		}
	}
}

/**
 * Get element with cursor/selection offset. Given a negative offset, traverse through the DOM
 * tree to find the appropriate element.
 * @param  {DOMNode} element    Element to traverse from
 * @param  {Number} offset      Cursor/selection offset.
 * @return {[element, offset]}  Touple containing new element and (positive) offset.
 * @private
 */
function findOffsetElement(element, offset) {
	// If the offset is within this element, we can return.
	if (offset &gt;= 0) return [ element, offset ];

	// Explore the previous sibling's children if has children.
	if (element.lastChild) {
		offset = element.lastChild.nodeType === document.TEXT_NODE
			? offset + element.lastChild.length : offset;
		return findOffsetElement(element.lastChild, offset);
	}

	if (!element.previousSibling) {
		// If he element isn't a text node and has no children, we move up the tree to explore the
		// parent node.
		offset = element.parentNode.nodeType === document.TEXT_NODE
			? offset + element.parentNode.length : offset;
		return findOffsetElement(element.parentNode, offset);
	}

	// Explore the previous sibling if it's a text node. This recursion will converge towards a
	// positive offset.
	if (element.previousSibling.nodeType === document.TEXT_NODE) {
		return findOffsetElement(element.previousSibling,
			offset + element.previousSibling.nodeValue.length);
	}
}

/**
 * Find selection range in node if it exists.
 * @param  {TextNode} textNode TextNode to look for Range in.
 * @return {mixed}             Basic object containing the essential properties of a Range object.
 * @private
 */
function getSelectionRange(textNode) {
	// If there are no selections, return.
	if (window.getSelection().rangeCount === 0) {
		return;
	}

	var realRange = window.getSelection().getRangeAt(0);
	// If selection isn't in this node, return.
	if (realRange.commonAncestorContainer !== textNode) {
		return;
	}

	// Finally, return the range. We can't return the original range, as it may change. Since the
	// range is already bound to the DOM, if we clone it, the cloned range will also be bound to the
	// DOM. If any changes are made to the involved TextNode, then the offsets will therefore be
	// set to 0. Therefore, we mange a basic object containing the essential properties of a real
	// Range object.
	var fakeRange = {
		startOffset: realRange.startOffset,
		startContainer: realRange.startContainer,
		endOffset: realRange.endOffset,
		endContainer: realRange.endContainer
	};
	return fakeRange;
}

/**
 * Set selection on textnode based on fakeRange. Uses findOffsetElement to fix negative offsets.
 * @param {TextNode} textNode  TextNode to base selection around.
 * @param {mixed} fakeRange    Basic object containing the essential properties of a Range object.
 * @private
 */
function setSelectionRange(textNode, fakeRange) {
	var realRange = document.createRange();

	if (fakeRange.startOffset &lt; 0) {
		var [startContainer, startOffset] = findOffsetElement(fakeRange.startContainer,
			fakeRange.startOffset);
		fakeRange.startContainer = startContainer;
		fakeRange.startOffset = startOffset;
	}

	if (fakeRange.endOffset &lt; 0) {
		var [endContainer, endOffset] = findOffsetElement(fakeRange.endContainer,
			fakeRange.endOffset);
		fakeRange.endContainer = endContainer;
		fakeRange.endOffset = endOffset;
	}

	realRange.setStart(fakeRange.startContainer, fakeRange.startOffset);
	realRange.setEnd(fakeRange.endContainer, fakeRange.endOffset);
	window.getSelection().removeAllRanges();
	window.getSelection().addRange(realRange);
}

/**
 * Recursively navigates an element using path to insert text at an index.
 * @param {DOMNode} parentElement DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {int} charIndex         Index in existing string to insert new string at.
 * @param {string} value          String to be inserted.
 * @private
 */
function insertInText(rootElement, path, charIndex, value) {
	let [childElement, /*childIndex*/, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);
	let attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;

	switch (indexType) {
		case jsonml.TAG_NAME_INDEX:
			// Diff changes to tag names is not supported.
			throw Error('Unsupported indexType jsonml.TAGNAME_INDEX (0)');
		case jsonml.ATTRIBUTE_INDEX:
			// This is not necessarily an attribute change, because the attribute object in JsonML is
			// optional. Therefore, it may just be a change made to a comment or regular text node
			// without an attribute object. We verify by seeing if an attribute name exists.
			if (attributeName) {
				// Attribute value diff.
				attributeName = path.pop();
				// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,
				// which messes up our attribute diffing. We also do this in deleteInText below.
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				let oldValue = childElement.getAttribute(attributeName);
				if (isSvgPath) oldValue = childElement.__d;
				const newValue = oldValue.substring(0, charIndex)
					+ value + oldValue.substring(charIndex);
				if (isSvgPath) childElement.__d = newValue;
				childElement.setAttribute(attributeName, newValue);
				coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
					false);
				coreEvents.triggerEvent('DOMAttributeTextInsertion', childElement, attributeName, charIndex,
					value, false);
				break;
			}
			// falls through if not an attribute value change.
		default:
			// Text node or comment content change.
	    var isComment = parentElement.nodeType === document.COMMENT_NODE;
	    parentElement = isComment ? parentElement : childElement;
	    var oldValue = parentElement.data;
            // var oldValue = parentElement.innerText;
	    var newValue = oldValue.substring(0, charIndex)
		+ value + oldValue.substring(charIndex);
	    // Generate current text selection range.
	    var fakeRange = getSelectionRange(parentElement);
	    parentElement.data = newValue;
            // parentElement.innerText = newValue;

			if (fakeRange) {
				// Adjust the range to account for the insertion.
				if (fakeRange.endContainer === parentElement &amp;&amp; fakeRange.endOffset &gt; charIndex) {
					fakeRange.endOffset += value.length;
					if (fakeRange.startContainer === parentElement &amp;&amp; fakeRange.startOffset &gt;= charIndex) {
						fakeRange.startOffset += value.length;
					}
				}
				// Update selection.
				setSelectionRange(parentElement, fakeRange);
			}

			coreEvents.triggerEvent('DOMTextNodeInsertion', childElement, parentElement, charIndex,
				value);
			break;
	}

	// Create and dispatch deprecated events.
	// TODO: This should be removed, eventually.
	var event = new CustomEvent('insertText', {
		detail: { position: charIndex, value: value, attributeName: attributeName }
	});
	parentElement.dispatchEvent(event);

}

/**
 * Recursively navigates an element using path to delete text at an index.
 * @param {DOMNode} parentElement DOMNode used as root element for path navigation.
 * @param {DOMPath} path          Path to follow on DOMNode.
 * @param {int} charIndex         Index in existing string to remove string from.
 * @param {string} value          String to be removed.
 * @private
 */
function deleteInText(rootElement, path, charIndex, value) {
	let [childElement, /*childIndex*/, parentElement, indexType] =
		corePathTree.elementAtPath(rootElement, path);
	let attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;

	switch (indexType) {
		case jsonml.TAG_NAME_INDEX:
			// Diff changes to tag names is not supported.
			throw Error('Unsupported indexType jsonml.TAGNAME_INDEX (1)');
		case jsonml.ATTRIBUTE_INDEX:
			if (attributeName) {
				// Attribute value diff.
				attributeName = path.pop();
				// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,
				// which messes up our attribute diffing. We also do this in insertInText above.
				const isSvgPath = childElement.tagName.toLowerCase() === 'path' &amp;&amp; attributeName === 'd';
				let oldValue = childElement.getAttribute(attributeName);
				if (isSvgPath) oldValue = childElement.__d;
				const newValue = oldValue.substring(0, charIndex)
					+ oldValue.substring(charIndex + value.length);
				if (isSvgPath) childElement.__d = newValue;
				childElement.setAttribute(attributeName, newValue);
				coreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,
					false);
				coreEvents.triggerEvent('DOMAttributeTextDeletion', childElement, attributeName, charIndex,
					value, false);
				break;
			}
			// If not an attribute value change: falls through.
		default:
			// Text node or comment content change.
			var isComment = parentElement.nodeType === document.COMMENT_NODE;
			parentElement = isComment ? parentElement : childElement;
			// Generate current text selection range.
			var fakeRange = getSelectionRange(parentElement);
	    var oldValue = parentElement.data;
            // var oldValue = parentElement.innerText;
			var newValue = oldValue.substring(0, charIndex)
				+ oldValue.substring(charIndex + value.length);
	    parentElement.data = newValue;
            // parentElement.innerText = newValue;

			if (fakeRange) {
				// Adjust the range to account for the deletion.
				if (fakeRange.endContainer === parentElement &amp;&amp; fakeRange.endOffset &gt; charIndex) {
					fakeRange.endOffset -= value.length;
					if (fakeRange.startContainer === parentElement &amp;&amp; fakeRange.startOffset &gt;= charIndex) {
						fakeRange.startOffset -= value.length;
					}
				}
				// Update selection.
				setSelectionRange(parentElement, fakeRange);
			}

			coreEvents.triggerEvent('DOMTextNodeDeletion', childElement, parentElement, charIndex, value);
			break;
	}

	// Create and dispatch deprecated events. This should be removed, eventually.
	const event = new CustomEvent('deleteText', {
		detail: { position: charIndex, value: value, attributeName: attributeName }
	});
	parentElement.dispatchEvent(event);

	// Notify deleteText listeners.
	//coreEvents.triggerEvent("deleteText", charIndex, value, attributeName);
}

/**
 * Apply an operation to an element.
 * @param  {Op} op   Operation to be applied. Contains path and op type.
 * @param  {DOMNode} DOMNode used as root element for path navigation.
 * @public
 */
function applyOp(op, rootElement) {
	let charIndex, attributeName;
	const path = op.p;
	if (path.length === 0) {
		return;
	}

	// We have to use "prop in obj" syntax, because not all properties have a value, necessarily
	// (i.e. `oi`).
	if ('si' in op || 'sd' in op) {
		// For string insertions and string deletions, we extract the character index from the path.
		charIndex = path.pop();
	}

	if ('oi' in op || 'od' in op) {
		// For attribute insertions and attribute deletions, we extract the attribtue name from the
		// path.
		attributeName = path.pop();
	}
	// Attribute insertion (object insertion). Also catches replace operations, i.e. operations with
	// both `oi` and `od`.
	if ('oi' in op) {
		return setAttribute(rootElement, path, attributeName, op.oi);
	}

	// Attribute removal (object deletion)
	if ('od' in op) {
		return removeAttribute(rootElement, path, attributeName);
	}

	// String deletion.
	if ('sd' in op) {
		return deleteInText(rootElement, path, charIndex, op.sd);
	}

	// String insertion.
	if ('si' in op) {
		return insertInText(rootElement, path, charIndex, op.si);
	}

	// Node replacement, either a regular node, tag renaming, or a complete replacement of
	// attributes.
	if ('li' in op &amp;&amp; 'ld' in op) {
		return replaceNode(rootElement, path, op.li);
	}

	// Element deletion operation (list deletion).
	if ('ld' in op) {
		return deleteNode(rootElement, path);
	}

	// Element insertion operation (list insertion).
	if ('li' in op) {
		return insertNode(rootElement, path, op.li);
	}
}

function applyOpReverse(op, rootElement) {
    let charIndex, attributeName;
    const path = op.p;
    if (path.length === 0) {
	return;
    }

    // We have to use "prop in obj" syntax, because not all properties have a value, necessarily
    // (i.e. `oi`).
    if ('si' in op || 'sd' in op) {
	// For string insertions and string deletions, we extract the character index from the path.
	charIndex = path.pop();
    }

    // No need to change
    if ('oi' in op || 'od' in op) {
	// For attribute insertions and attribute deletions, we extract the attribtue name from the
	// path.
	attributeName = path.pop();
    }
    // Attribute insertion (object insertion). Also catches replace operations, i.e. operations with
    // both `oi` and `od`.
    // SWAPED
    if ('oi' in op) {
	return removeAttribute(rootElement, path, attributeName);
    }

    // Attribute removal (object deletion)
    // SWAPED
    if ('od' in op) {
        return setAttribute(rootElement, path, attributeName, op.od);
	// return removeAttribute(rootElement, path, attributeName);
    }

    // String deletion.
    // SWAPED
    if ('sd' in op) {
        return insertInText(rootElement, path, charIndex, op.sd);
	// return deleteInText(rootElement, path, charIndex, op.sd);
    }

    // String insertion.
    // SWAPED
    if ('si' in op) {
        return deleteInText(rootElement, path, charIndex, op.si);
	// return insertInText(rootElement, path, charIndex, op.si);
    }

    // Node replacement, either a regular node, tag renaming, or a complete replacement of
    // attributes.
    // SWAPED
    if ('li' in op &amp;&amp; 'ld' in op) {
	return replaceNode(rootElement, path, op.ld);
    }

    // Element deletion operation (list deletion).
    // Swaped
    if ('ld' in op) {
        return insertNode(rootElement, path, op.ld); // CHECK this
	// return deleteNode(rootElement, path);
    }

    // Element insertion operation (list insertion).
    // Swaped
    if ('li' in op) {
	// return insertNode(rootElement, path, op.li);
        return deleteNode(rootElement, path);
    }
}



// coreOpApplier.listenForOpsAndApplyOn = (rootElement) =&gt; {
// 	coreEvents.addEventListener('receivedOps', (ops) =&gt; {
// 		// We disable the mutation observers before applying the operations. Otherwise, applying the
// 		// operations would cause new mutations to be created, which in turn would cause the
// 		// creation of new operations, leading to a livelock for all clients.
// 		coreMutation.pause();

// 		ops.forEach((op) =&gt; {
// 			applyOp(op, rootElement);
// 		});

// 		// And re-enable MuationObservers.
// 		coreMutation.resume();
// 	}, coreEvents.PRIORITY.IMMEDIATE);
// };


coreEvents.createEvent('receivedOpsStlk', { idempotent: true });

// coreOpApplier.listenForOpsAndReApplyOn = () =&gt; {
    coreEvents.addEventListener('receivedOpsStlk', (rootElement, ops) =&gt; {
	// We disable the mutation observers before applying the operations. Otherwise, applying the
	// operations would cause new mutations to be created, which in turn would cause the
	// creation of new operations, leading to a livelock for all clients.
	coreMutation.pause();
        //        debugger;

        var op = ops
	// ops.forEach((op) =&gt; {
	applyOpReverse(op, rootElement);
        // applyOp()
	// });
        
	// And re-enable MuationObservers.
	coreMutation.resume();
    }, coreEvents.PRIORITY.IMMEDIATE);
// };


// coreEventsModule.triggerEvent("receivedOpsStlk", rootElement, ops)
// module.exports = coreOpApplier;

//////////////////////////////////////
</pre></div><div class="paragraph code-paragraph" data-id="uuwCK9Nh" name="opsUtils" last-execution-state="success"><pre data-type="content" type="text/javascript" id="opsUtils"> 
const ParagraphUtils = require("#paragraph-utils");
const HelperFunctions = require("#helperFunctions")


// recursively search for PathNodes of the code cell

let target,
    codeCell;

target = [];

// TODO: last-execution-state
// TODO: different contributors
// TODO: patching diff

// TODO: output

// TODO: vistrate

// TODO: get current element name
// document.getElementsByName("idVersionNew")[0].__pathNodes[0].children[0].DOMNode


// TODO: change scope of variables
const recOps = function(el) {

    var element;    
    if (Array.isArray(el)) { // INFO: for the nested elements
        
        el.forEach(elNest =&gt; {

            element = {
                id: elNest.id,
                path: elNest.toPath()
            }
            
            target.push(element)
            
            if (elNest.children) {
                recOps(elNest.children)
            }        
        })
    } else { // INFO: for the head element

        element = {
            id: el.id,
            path: el.toPath()
        }
        
        // target.push(element)
        
        if (el.children) {
            recOps(el.children)
        }

    }

    return target
}



// finding relevant pieces in getOps

// INFO: finding right nodes by the path
// FIXME: not optimal
// FIXME: receive ops before that

const findRelevantPiecesInOps = (target) =&gt; {
  
  let ind,
	tmpArray;
var targetTmp,
    opContainer;

ind = []
tmpArray = [...temp14]

targetTmp = [target[2]] // FIXME: filter target to be unique
target.forEach(cellLine =&gt; { // INFO: for each path of the cell line

    // cellLine.path
    tmpArray.forEach(el =&gt; { // INFO: for each version
        
        (el.op !== undefined) &amp;&amp; el.op.forEach(op =&gt; { // INFO: for each op

               
            if (cellLine.path.length &lt; op.p.length) {
                
                opContainer = [...op.p]
                opContainerBeforeMutation = [...op.p]
                opContainer.pop()
                
                
                
                (opContainer, cellLine.path)
                    &amp;&amp; ind.push({
                        path: opContainerBeforeMutation,
                        version: el.v,
                        change: 
                  
                  
                  (op, "p")})    
            } else {

                opContainer = [...op.p]
                compareArrays(opContainer, cellLine.path)
                    &amp;&amp; ind.push({
                        path: opContainer,
                        version: el.v,
                        change: FilterObjectByKey(op, "p")})
                // compareArrays(opContainer, cellLine.path) &amp;&amp; console.log("TRUE, Op path: ", opContainer, "Target Path: ", cellLine.path,  "\n version: ", el.v)
                
            }
            
        })
        
    })

})

  
  return ind
  
}


const sortNclear = (ind) =&gt; {

  ind.sort(HelperFunctions.compareSort)

// INFO: delete duplicates (why the hell?)

// delete duplicates based on:
// arrays (paths)
// version numbers
var indClear = ind.reduce((acc, value) =&gt; {

    if (acc.length &gt; 0) {  // INFO: after second call I can compare
        // SOLVED: first two duplicates are not removed
        
        if (acc[acc.length - 1].version === value.version // INFO: comparing current with previous
            &amp;&amp; compare(acc[acc.length - 1].path, value.path)) { // INFO: if previous is the same
            // INFO: not pushing duplicates
        } else { // INFO: push unique
	    acc.push(value) // FIXME:
        }
        
    } else {

        // INFO: if it is first call, just push
        acc.push(value) // FIXME:
    }
    
    return acc
    
}, [])
  
  
}


// FIXME: use paragraph
const processOpsAndApply = (paragraph) =&gt; {
    
    var rootTmp = document.getElementsByName("idVersionNew")[0].__pathNodes[0].children[0].DOMNode
    var temp14;

    webstrate.getOps(webstrate.version - 1, webstrate.version, (x, y) =&gt; {temp14 = y})
    var opInst = [...temp14];
    var opTry = opInst[opInst.length - 1].op[0]

    opTry.p = opTry.p.splice(-2)

    setTimeout(() =&gt; {
        coreEventsModule.triggerEvent("receivedOpsStlk", rootTmp, opTry)
    }, 1000)
    
}


const processOpsAndApplyMultiple = (paragraph) =&gt; {
  
  opInst.forEach(el =&gt; {

    el.op.forEach(op =&gt; {
        op.p = [op.p.pop()]
        applyOp(op, rootTmp)
    })

})

}




exports = Object.assign(exports, {recOps, findRelevantPiecesInOps, 
                                  sortNclear, 
                                  processOpsAndApply, processOpsAndApply, processOpsAndApplyMultiple})</pre></div><div class="paragraph code-paragraph" data-id="N4V8aEMg"><pre data-type="content" type="text/javascript">// JavaScript code here

const opsUtils = require("#opsUtils")

var target = opsUtils.recOps(document.getElementsByName("idVersion2")[0].children[2].__pathNodes[0])


var ind = opsUtils.findRelevantPiecesInOps(target)


var acc = opsUtils.sortNClear(ind)
opsUtils.processOpsAndApply()
// OR
// opsUtils.processOpsAndApply
</pre></div><div class="paragraph code-paragraph" data-id="3widdW9p" name="Versioning Utils" last-execution-state="success" style="" draggable="false" run-on-load="true"><pre data-type="content" type="text/javascript" id="versioning-utils">const toggleBackContributor = (paragraph) =&gt; {
    console.log("Back Contributor")
}

const toggleForwardContributor = (paragraph) =&gt; {
    console.log("Forward Contributor")
}

const toggleBackError = (paragraph) =&gt; {
    
}
const toggleForwardError = (paragraph) =&gt; {
}

const toggleBackSuccess = (paragraph) =&gt; {

}

const toggleForwardSuccess = (paragraph) =&gt; {

}


const toggleBackTiny = (paragraph) =&gt; {
    console.log("Back Tiny");
    console.log(paragraph)
}
const toggleBackCardinal = (paragraph) =&gt; {
    console.log("Back Cardinal");
    console.log(paragraph)
}
const toggleForwardTiny = (paragraph) =&gt; {
    console.log("Forward Tiny");
    console.log(paragraph)
}
const toggleForwardCardinal = (paragraph) =&gt; {
    console.log("Forward Cardinal");
    console.log(paragraph)
};

exports = Object.assign(exports, {toggleBackTiny, toggleBackCardinal, toggleForwardTiny, toggleForwardCardinal })</pre></div><div class="paragraph code-paragraph" data-id="Cqhpj3an" name="Versioning UI" last-execution-state="success" run-on-load="true"><pre data-type="content" type="text/javascript" id="versioning-ui">
const VersioningUtils = require("#versioning-utils");

importLib([
    "hammer.min.js",
    "hammer-time.min.js"
]).then(() =&gt; {

    const ParagraphUtils = require("#paragraph-utils");

    let addVersioningButton = (paragraph) =&gt; {

	let header = ParagraphUtils.getHeaderElement(paragraph);

	// Make sure to add action only once, e.g. triggered multiple times on paragraph drag and drop
	if (header.querySelector(".toggle-versioning-back-tiny")) {
	    return;
	}

        // Back tiny
	let actionBackTiny = document.createElement("div");
	actionBackTiny.classList.add("action");
	actionBackTiny.classList.add("toggle-versioning-back-tiny");
	actionBackTiny.setAttribute("tooltip", "true");
	
	let iconBackTiny = document.createElement("i");
	iconBackTiny.classList.add("material-icons");
	actionBackTiny.appendChild(iconBackTiny);
	header.appendChild(actionBackTiny);

        // Back cardinal
	let actionBackCardinal = document.createElement("div");
	actionBackCardinal.classList.add("action");
	actionBackCardinal.classList.add("toggle-versioning-back-cardinal");
	actionBackCardinal.setAttribute("tooltip", "true");
	
	let iconBackCardinal = document.createElement("i");
	iconBackCardinal.classList.add("material-icons");
	actionBackCardinal.appendChild(iconBackCardinal);
	header.appendChild(actionBackCardinal);

        // Forward Tiny
	let actionForwardTiny = document.createElement("div");
	actionForwardTiny.classList.add("action");
	actionForwardTiny.classList.add("toggle-versioning-forward-tiny");
	actionForwardTiny.setAttribute("tooltip", "true");
	
	let iconForwardTiny = document.createElement("i");
	iconForwardTiny.classList.add("material-icons");
	actionForwardTiny.appendChild(iconForwardTiny);
	header.appendChild(actionForwardTiny);

        // Forward cardinal
	let actionForwardCardinal = document.createElement("div");
	actionForwardCardinal.classList.add("action");
	actionForwardCardinal.classList.add("toggle-versioning-forward-cardinal");
	actionForwardCardinal.setAttribute("tooltip", "true");
	
	let iconForwardCardinal = document.createElement("i");
	iconForwardCardinal.classList.add("material-icons");
	actionForwardCardinal.appendChild(iconForwardCardinal);
	header.appendChild(actionForwardCardinal);


        [{action: actionBackTiny, desc: "actionBackTiny"}, {action: actionBackCardinal, desc: "actionBackCardinal"},
         {action: actionForwardTiny, desc: "actionForwardTiny"}, {action: actionForwardCardinal, desc: "actionForwardCardinal"}].forEach(action =&gt; {


             var mc = new Hammer.Manager(action.action);
             
	     mc.add(new Hammer.Tap({
	         event: "tap",
	         taps: 1
	     }));

	     mc.add(new Hammer.Press({
	         event: "longpress",
	         time: 250
	     }));
             
             switch(action.desc) {

             case "actionBackTiny":
                 return  mc.on("tap", () =&gt; {
                     console.log("!")
          	     VersioningUtils.toggleBackTiny(paragraph);                 
	         });
             case "actionBackCardinal":
                 return   mc.on("tap", () =&gt; {
                     VersioningUtils.toggleBackCardinal(paragraph);
	         });
             case "actionForwardTiny":
                 return  mc.on("tap", () =&gt; {
                     VersioningUtils.toggleForwardTiny(paragraph);
	         });
             case "actionForwardCardinal":
                 return   mc.on("tap", () =&gt; {
                     VersioningUtils.toggleForwardCardinal(paragraph);
	         });
             }
             
             
         })
        
    };

    document.liveQuerySelectorAll(".paragraph").added(paragraph =&gt; {

        // only code paragraphs
        if (!paragraph.querySelector("pre[data-type='content']")) return;

        const header = ParagraphUtils.getHeaderElement(paragraph);
        const content = ParagraphUtils.getContentElement(paragraph);

        addVersioningButton(paragraph)
    });




// });

});

/******************************************************************************/

// TODO: exit versioning and return to the last state
// Exit fullscreen when transient fullscreen paragraph was deleted
// const selector = document.liveQuerySelectorAll('.paragraph.fullscreen');
// selector.removed(FullscreenUtils.exitFullscreen);

/******************************************************************/

codestrate.addCommand("codestrates.cellVersioning", "Cell Versioning", (event) =&gt; {
    
    console.log(event)
    
    let paragraph;
    if (event !== null &amp;&amp; event.target !== null) {
	let target = event.target;
        paragraph = target.closest(".paragraph");
    } else {
	// paragraph = codestrate.focussedParagraph;
    }
    // if (!paragraph) {
    // 	paragraph = document.querySelector(".paragraph.fullscreen:not([transient-fullscreen='false']),.paragraph[transient-fullscreen='true']");
    // }

    if (paragraph) {
	// FullscreenUtils.togglePersistedFullscreen(paragraph);
    }
});

codestrate.addKeyBinding("codestrates.cellVersioning", "ctrl+shift+v", true);


</pre></div><div class="paragraph style-paragraph collapsed" data-id="wHtYFUqf" name="Versioning Indicator"><style data-type="content" type="text/css">#cellVersioning-indicator {
	position: fixed;
	right: 0;
	top: 100px;
	width: 30px;
	height: 400px;
	cursor: pointer;

	color:  rgba(255, 255, 255, 0.2);
	background: rgba(0, 0, 0, 0.2);
	border-radius: 2px;
	z-index: 201;
}

#cellVersioning-indicator:hover {
	color: inherit;
	background: rgba(0, 0, 0, 0.3);
}

#cellVersioning-indicator:before {
	padding-left: 7px;
	padding-bottom: 7px;
	content: attr(icon);
	position: relative;
	display: inline-block;
	transform: rotate(90deg) translate3d(0, -100%, 0);
	transform-origin: 0 0 0;

	font-family: "Material Icons";
	font-weight: normal;
	font-style: normal;
	/* font-size: 24px; */
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: "liga";
}

#cellVersioning-indicator:after {
	padding: 5px;
	padding-left: 10px;
	content: attr(name);
	display: inline-block;
	width: 200px;
	position: relative;
	transform: rotate(90deg) translate3d(0, -100%, 0);
	transform-origin: 0 0 0;
}

#cellVersioning-indicator:not([name]):after {
	content: "No Name";
}

#cellVersioning-indicator.hidden {
	display: none;
}</style></div><div class="paragraph style-paragraph collapsed" data-id="CqSgXhhJ" name="Paragraph&nbsp;"><style data-type="content" type="text/css">html .paragraph .toggle-versioning-back-tiny,
html .paragraph .toggle-versioning-back-cardinal,
html .paragraph .toggle-versioning-forward-tiny, 
html .paragraph .toggle-versioning-forward-cardinal {
    margin-left: 5px;
    margin-right: 10px;
}


html .paragraph .toggle-versioning-back-tiny i:after {
	content: "keyboard_arrow_left";
}

html .paragraph .toggle-versioning-back-cardinal i:after {
	content: "fast_rewind";
}

html .paragraph .toggle-versioning-forward-tiny i:after {
	content: "keyboard_arrow_right";
}

html .paragraph .toggle-versioning-forward-cardinal i:after {
	content: "fast_forward";
}
</style></div></div>