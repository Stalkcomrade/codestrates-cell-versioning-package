<div class="section section-visible" data-id="RAAJuPq8" data-type="package" name="Activity Component"><div class="paragraph body-paragraph collapsed" name="Documentation" data-id="8VmzkBNb"><div data-type="content" type="text/html" contenteditable="true" class="section-documentation"><h2>Description</h2>
<div>Your description...</div></div></div><div class="paragraph data-paragraph" name="Properties" data-id="2qnziYCb"><pre data-type="content" type="application/json" class="section-properties">{
  "version": "0.2.0",
  "icon": "show_chart",
  "description": "Your short description.",
  "tags": [
    "Your tags"
  ],
  "assets": [
    "moment.min.js",
    "lodash.min.js",
    "d3.min.js"
  ],
  "changelog": {
    "0.3.0": "FIXED: styling",
    "0.2.0": "ADDED: interface for enabling components per chunk",
    "0.1.6": "checking how vue works in CS",
    "0.1.5": "ADDED: helper functions for transient container + DOM erase.",
    "0.1.0": "Initial version."
  },
  "github": {
    "url"   : "https://github.com/Stalkcomrade/codestrates-cell-versioning-package",
		"folder": "packages/RAAJuPq8-activityComponent"
  }
}</pre></div><div class="paragraph code-paragraph collapsed" data-id="n9vRiEuq" last-execution-state="success" run-on-load="true" name="helpers-underscore-moment"><pre data-type="content" type="text/javascript" id="helpers-underscore-moment">const vm = Codestrate.VirtualMachines.get("text/javascript");


importLib([
  "moment.min.js",
   "lodash.min.js",
   "d3.min.js"
]).then(() =&gt; {
  


const uuid = function b(a){return a?(a^Math.random()*16&gt;&gt;a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,b)}

const cloneDeep = _.cloneDeep
const isNull = _.isNull
const isDate = _.isDate
const isString = _.isString
const isFunction = _.isFunction

const isArray = Array.isArray
const isSimpleExtent = arr =&gt; isArray(arr) &amp;&amp; arr.length === 2
const isExtent = arr =&gt; isArray(arr) &amp;&amp; isArray(arr[0]) &amp;&amp; arr[0].length === 2 &amp;&amp; isArray(arr[1]) &amp;&amp; arr[1].length === 2
const map = Array.prototype.map;
const slice = Array.prototype.slice


vm.addToGlobalContext({
  uuid,
  cloneDeep,
  isNull,
  isDate,
  isString,
  isFunction,
  isArray,
  isSimpleExtent,
  isExtent,
  map,
  slice
});

  
  
})</pre></div><div class="paragraph code-paragraph" data-id="FzYWHuz8" name="options" run-on-load="true" last-execution-state="success"><pre data-type="content" type="text/javascript" id="options">const vm = Codestrate.VirtualMachines.get("text/javascript");

const options = { 
                        intervalCornerRadius: 4,
                        symbolSize: 400,
                        groupLabelFontSize: 12,
                        groupLabelFontWeight: 400,
                        groupLabelFontOpacity: 1,
                        groupLaneWidth: 200, // INFO: changes grouping width
                        tickSize: 20,
                        tickPadding: 8,
                        axisXLaneHeight: 600, // changes the height of groupping
                        axisFontSize: 16,
                        axisFontWeight: 600,
                        axisFontOpacity: 0.5,
                        axisXLabel: null,
                        axisLabelFontSize: 14,
                        axisLabelFontWeight: 600,
                        axisLabelFontOpacity: 1,
                        backgroundColor: 'rgba(255, 255, 255, 0.125)',
                        borderRadius: 0,
                        borderWidth: 2,
                        borderColor: 'rgba(0, 0, 0, .125)',
                        boundingLineWidth: 2,
                        boundingLineColor: 'rgba(0, 0, 0, .125)',
                        currentTimeLineWidth: 4,
                        currentTimeLineColor: 'rgba(255, 56, 96, 1)',
                        liveTimer: true,
                        liveTimerTick: 250,
                        scaleExtent: [0.05, Infinity]
                       
         }

vm.addToGlobalContext({
  options
});</pre></div><div class="paragraph code-paragraph" data-id="XZbmiC38" name="point-interval" run-on-load="true" last-execution-state="success"><pre data-type="content" type="text/javascript" id="point-interval">const vm = Codestrate.VirtualMachines.get("text/javascript");


class Point {
  constructor(group, at, title, symbol, className, link, webstrateId, version, globalIndex) {
    this.group = group;
    this.at = at;
    this.title = title;
    this.symbol = symbol;
    this.className = className;
    this.link = link;
    this.webstrateId = webstrateId;
    this.version = version;
    this.globalIndex = globalIndex;
    }
}


/**
 *
 * time entry that represent a period
 *
 * @param {string} group
 * @param {Date} from
 * @param {Date} to
 * @param {string} label
 * @param {string} title
 * @param {string} className
 * @constructor
 */
class Interval {
    constructor (group, from, to, label, title, className, version, globalIndex) {
        this.group = group;
        this.from = from;
        this.to = to;
        this.label = label;
        this.title = title;
        this.className = className;
    	  this.version = version;
    		this.globalIndex = globalIndex;
    }
}

vm.addToGlobalContext({
  Point,
  Interval
});
</pre></div><div class="paragraph code-paragraph" data-id="4XsLZMub" last-execution-state="success" run-on-load="true" name="aggregation"><pre data-type="content" type="text/javascript" id="aggregation">const vm = Codestrate.VirtualMachines.get("text/javascript");


/**
 * check if two entries collide
 *
 * @param e1
 * @param e2
 */
const isCollided = (e1, e2) =&gt; {
    if (e1 === e2) {
        return false;
    }

    if (e1 instanceof Point &amp;&amp; e2 instanceof Interval) {
        return e1.at.valueOf() &gt;= e2.from.valueOf() &amp;&amp; e1.at.valueOf() &lt;= e2.to.valueOf();
    }

    else if (e1 instanceof Interval &amp;&amp; e2 instanceof Point) {
        return e2.at.valueOf() &gt;= e1.from.valueOf() &amp;&amp; e2.at.valueOf() &lt;= e1.to.valueOf();
    }

    else if (e1 instanceof Point &amp;&amp; e2 instanceof Point) {
        return e1.at.valueOf() === e2.at.valueOf();
    }

    else if (e1 instanceof Interval &amp;&amp; e2 instanceof Interval) {
        return (e2.from.valueOf() &lt;= e1.to.valueOf() &amp;&amp; e2.to.valueOf() &gt;= e1.to.valueOf())
            || (e1.from.valueOf() &lt;= e2.to.valueOf() &amp;&amp; e1.to.valueOf() &gt;= e2.to.valueOf());
    }
};

/**
 *
 * asc sort order
 *
 * @param a
 * @param b
 * @returns {number}
 */
const ascending = (a, b) =&gt; a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;

/**
 *
 * @param data
 * @returns {*}
 */
const sort = (data) =&gt; {
    return data.sort((a, b) =&gt; {
        if (a instanceof Point &amp;&amp; b instanceof Interval) {
            return ascending(a.at, b.from);
        }

        else if (a instanceof Interval &amp;&amp; b instanceof Point) {
            return ascending(a.from, b.at);
        }

        else if (a instanceof Interval &amp;&amp; b instanceof Interval) {
            return ascending(a.from, b.from);
        }

        else if (a instanceof Point &amp;&amp; b instanceof Point) {
            return ascending(a.at, b.at);
        }
    });
};


const chunk = (data) =&gt; {
    const results = [
        []
    ];

    sort(data);

    for (let i = 0, l = data.length; i &lt; l; i += 1) {
        const entry = data[i];

        for (let j = 0, L = results.length; j &lt; L; j += 1) {
            if (results[j].length === 0) {
                results[j].push(entry);
                break;
            }

            const lastItem = results[j][results[j].length - 1];

            if (!isCollided(lastItem, entry)) {
                results[j].push(entry);
                break;
            }

            else {
                if (j === results.length - 1) {
                    results.push([entry]);
                } else {
                    continue;
                }
            }
        }
    }

    return results;
};

/**
 *
 * get every group's data
 *
 * @param data
 */
const groupBy = (data) =&gt; {
    const results = {};
    let dateTimeStart, dateTimeEnd;

    for (let i = 0, l = data.length; i &lt; l; i += 1) {
        var entry = data[i],
              { group, from, to, label, at, title, className, symbol, link, webstrateId, 
               globalIndex, version, state} = entry;
      
      from = new Date(from)
      to = new Date(to)
      at = new Date(at)

        if (isDate(from) &amp;&amp; isDate(to) &amp;&amp; from &lt; to &amp;&amp; (isString(group) || isFunction(group.toString))) {
            dateTimeStart = !dateTimeStart
                ? from
                : (dateTimeStart &gt; from ? from : dateTimeStart);

            dateTimeEnd = !dateTimeEnd
                ? to
                : (dateTimeEnd &lt; to ? to : dateTimeEnd);

            if (results[group]) {
                results[group].push(new Interval(group, from, to, label, title, className, globalIndex, version));
            }

            else {
                results[group] = [new Interval(group, from, to, label, title, className, globalIndex, version)];
            }
        }

      // Point definition 
      
        else if (isDate(at) &amp;&amp; (isString(group) || isFunction(group.toString))) {
            dateTimeStart = !dateTimeStart
                ? at
                : (dateTimeStart &gt; at ? at : dateTimeStart);

            dateTimeEnd = !dateTimeEnd
                ? at
                : (dateTimeEnd &lt; at ? at : dateTimeEnd);

            if (results[group]) {
              results[group].push(new Point(group, at, title, symbol, className, link, globalIndex, version));
            }

            else {
              results[group] = [new Point(group, at, title, symbol, className, link, globalIndex, version)];
            }
        }
    }

    return {
        dateTimeStart,
        dateTimeEnd,
        results
    };
};

const getTimelineGroups = (data) =&gt; {
    const {results, dateTimeStart, dateTimeEnd} = groupBy(data),
        groups = Object.keys(results);

    if (!groups.length) {
        return {
            dateTimeStart: moment().startOf('year'),
            dateTimeEnd: moment(),
            data: {},
            groups,
        }
    }

    if (dateTimeStart.valueOf() === dateTimeEnd.valueOf()) {
        return groups.reduce((ite, cur) =&gt; {
            ite.data[cur] = chunk(results[cur]);
            return ite;
        }, {
            dateTimeStart: moment(dateTimeStart).subtract(6, 'months'),
            dateTimeEnd: moment(dateTimeEnd).add(6, 'months'),
            data: {},
            groups
        });
    }

    return groups.reduce((ite, cur) =&gt; {
        ite.data[cur] = chunk(results[cur]);
        return ite;
    }, {
        dateTimeStart,
        dateTimeEnd,
        data: {},
        groups
    });
};
          
/**
 *
 * select the correct paddingInner and paddingOuter for axis x
 *
 * @param {number} height
 * @return {[number, number]}
 */
const selectPaddingInnerOuterY = (height) =&gt; {
    let paddingInner = 0.2, paddingOuter = 0.1;

    if (height &gt; 560) paddingInner = 0.15;
    if (height &gt; 970) paddingInner = 0.1;

    return [paddingInner, paddingOuter];
};

/**
 * https://github.com/Stalkcomrade/Vs/blob/master/src/plugins/roundedRect.js
 * generate svg path's d to simulate rounded rect
 *
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {number} r
 * @param {boolean} tl
 * @param {boolean} tr
 * @param {boolean} bl
 * @param {boolean} br
 * @returns {string}
 */
const roundedRect = function (x, y, w, h, r, tl, tr, bl, br) {
    let retval;
    retval = 'M' + (x + r) + ',' + y;
    retval += 'h' + (w - 2 * r);
    if (tr) {
        retval += 'a' + r + ',' + r + ' 0 0 1 ' + r + ',' + r;
    } else {
        retval += 'h' + r;
        retval += 'v' + r;
    }
    retval += 'v' + (h - 2 * r);
    if (br) {
        retval += 'a' + r + ',' + r + ' 0 0 1 ' + -r + ',' + r;
    } else {
        retval += 'v' + r;
        retval += 'h' + -r;
    }
    retval += 'h' + (2 * r - w);
    if (bl) {
        retval += 'a' + r + ',' + r + ' 0 0 1 ' + -r + ',' + -r;
    } else {
        retval += 'h' + -r;
        retval += 'v' + -r;
    }
    retval += 'v' + (2 * r - h);
    if (tl) {
        retval += 'a' + r + ',' + r + ' 0 0 1 ' + r + ',' + -r;
    } else {
        retval += 'v' + -r;
        retval += 'h' + r;
    }
    retval += 'z';
    return retval;
}


vm.addToGlobalContext({
  isCollided,
  ascending,
  sort,
  chunk,
  groupBy,
  getTimelineGroups,
  selectPaddingInnerOuterY,
  roundedRect
});

</pre></div><div class="paragraph code-paragraph" data-id="rCS8sqHQ" run-on-load="true" last-execution-state="success" name="draw-entries-reference"><pre data-type="content" type="text/javascript" id="draw-entries-reference">const vm = Codestrate.VirtualMachines.get("text/javascript");


importLib([
    "moment.min.js",
    "lodash.min.js",
    "d3.min.js"
]).then(() =&gt; {
    


    /**
     *
     * @param g
     * @param data
     * @param groups
     * @param xScale
     * @param yScale
     * @param symbolSize
     * @param intervalCornerRadius
     */
    const drawEntriesMultiLaneX = (g, data, groups, xScale, yScale, symbolSize, intervalCornerRadius, roundedRect) =&gt; {
        const entriesSelection = g.selectAll('.entry');
        if (!entriesSelection.empty()) entriesSelection.remove();

        for (let i = 0, l = groups.length; i &lt; l; i += 1) {
            const groupData = data[groups[i]];
            const scaleAxisY = yScale(i).domain(Object.keys(groupData));

            for (let j = 0; j &lt; groupData.length; j += 1) {
                const Y = scaleAxisY(j.toString()),
                      H = scaleAxisY.bandwidth(),
                      entries = groupData[j];

                for (let k = 0; k &lt; entries.length; k += 1) {
                    const entry = entries[k];

                    // Point def
                    
                    if (entry instanceof Point) {
                        const symbolGen = d3.symbol().size(symbolSize);

                        const symbol = g.append('path')
                              .attr('transform', `translate(${xScale(entry.at)}, ${Y + H / 2})`)
                              .attr('class', `entry ${entry.className ? entry.className : 'entry--point--default'}`)
                              .attr('d', symbolGen.type(d3[entry.symbol] || d3['symbolCircle'])())
                              .attr('href', entry.link)
                              .on('click', () =&gt; { console.log(entry)});
                        
                    }

                    else if (entry instanceof Interval) {
                        const X = xScale(entry.from),
                              W = xScale(entry.to) - X;

                        try {

                            const interval = g.append('path')
                                  .attr('class', `entry ${entry.className ? entry.className : 'entry--interval--default'}`)
                                  .attr('d', () =&gt; roundedRect(X, Y, W, H, intervalCornerRadius, true, true, true, true))
                                  .on('click', () =&gt; { console.log(entry)});
                            
                            // if (entry.title) {
                                // interval
                                // .on('mouseover', showTip(entry.title))
                                // .on('mouseout', hideTip);
                            // }
                            
                        } catch (err) {
                            console.error("Test:", err)
                            
                        } finally {
                            
                        }
                        
                        const text = g.append('text')
                              .attr('class', 'entry entry--label')
                              .attr('text-anchor', 'middle')
                              .attr('pointer-events', 'none')
                              .attr('x', (X + W / 2))
                              .attr('y', (Y + H / 2))
                              .text(entry.label)
                              .attr('fill', '#fff')
                              .attr('dy', '0.32em');

                        if (text.node().getComputedTextLength() &gt; W) {
                            text.remove();
                        }
                    }
                }
            }
        }
    };

    /**
     * https://github.com/Stalkcomrade/Vs/blob/master/src/plugins/drawCurrentReference.js
     * @param g
     * @param xScale
     * @param g_h
     * @param currentTimeLineColor
     * @param currentTimeLineWidth
     */
    const drawCurrentReferenceX = (g, xScale, g_h, currentTimeLineColor, currentTimeLineWidth) =&gt; {
        const date = new Date(),
              referenceSelection = g.select('.line--reference');

        if (!referenceSelection.empty()) {
            referenceSelection
                .attr('x1', xScale(date))
                .attr('x2', xScale(date));
        } else {
            g.append('line')
                .attr('class', 'line--reference')
                .attr('x1', xScale(date))
                .attr('x2', xScale(date))
                .attr('y2', g_h)
                .attr('stroke', currentTimeLineColor)
                .attr('stroke-width', currentTimeLineWidth)
                .attr('pointer-events', 'none');
        }
        // if (!referenceSelection.empty()) referenceSelection.remove();
        //
        // g.append('line')
        //     .attr('class', 'line--reference')
        //     .attr('x1', xScale(date))
        //     .attr('x2', xScale(date))
        //     .attr('y1', 0)
        //     .attr('y2', g_h)
        //     .attr('stroke', currentTimeLineColor)
        //     .attr('stroke-width', currentTimeLineWidth)
        //     .attr('clip-path', `url(#${clipPathId})`)
        //     .attr('pointer-events', 'none');
    };


    /**
     * https://github.com/Stalkcomrade/Vs/blob/master/src/components/d3Timeline/drawGen.js
     * @param axisXLane
     * @param xAxis
     * @param yScale
     * @param data
     * @param groups
     * @param g_h
     * @param symbolSize
     * @param intervalCornerRadius
     * @param currentTimeLineColor
     * @param currentTimeLineWidth
     * @param boundingLineColor
     * @param boundingLineWidth
     */
    const drawGen = (
        axisXLane,
        xAxis,
        yScale,
        data,
        groups,
        g_h,
        symbolSize,
        intervalCornerRadius,
        currentTimeLineColor,
        currentTimeLineWidth,
        boundingLineColor,
        boundingLineWidth
    ) =&gt; {
        return (g, xScale) =&gt; {
            axisXLane
                .call(xAxis.scale(xScale))
                .selectAll('line')
                .attr('y1', -g_h)
                .attr('stroke', boundingLineColor)
                .attr('stroke-width', boundingLineWidth);

            g
                .call(drawEntriesMultiLaneX, data, groups, xScale, yScale, symbolSize, intervalCornerRadius, roundedRect)
            // .call(drawEntriesMultiLaneX, data, groups, xScale, yScale, symbolSize, intervalCornerRadius)
            
                .call(drawCurrentReferenceX, xScale, g_h, currentTimeLineColor, currentTimeLineWidth);
        }
    };

    vm.addToGlobalContext({
        drawEntriesMultiLaneX,
        drawCurrentReferenceX,
        drawGen
    });
    
})</pre></div><div class="paragraph code-paragraph collapsed" data-id="T9XWjRQf" run-on-load="true" last-execution-state="success" name="brush"><pre data-type="content" type="text/javascript" id="brush">const vm = Codestrate.VirtualMachines.get("text/javascript");


importLib([
  "moment.min.js",
   "lodash.min.js",
   "d3.min.js"
]).then(() =&gt; {
  

/**
 *
 * @param extent
 * @param scale
 * @param data
 * @return {*[]}
 */
const brushInvertUn = (extent, scale, data, scaleY) =&gt; {
    if (isNull(d3.event.selection)) return;
    
// TODO: unite into one call?
//     debugger;
//     const [xLeft, xRight] = map
//         .call(d3.event.selection, el =&gt; el - extent[0][0]);
  
    console.log(data)
   const [yTop, yBottom] = map
        .call(d3.event.selection, el =&gt; el[1] - extent[0][1]);

  //console.log(imageScale.invert(xPos));
  // var eachBand = scaleY.step();
  // var index = Math.round((d3.event.y / eachBand));
  // var val = scaleY.domain()[index];
  
  // var imageScale = scaleY
  // var leftEdges = imageScale.range();
  // var width = imageScale.rangeBand();

    console.log(yTop)
    console.log(yBottom)
    
    var invertC = function(x){
        
      
      var eachBand = scaleY.step();
      console.log(scaleY.step())
      var index = Math.round(x / eachBand);
      console.log("index = ", index);
      var val = scaleY.domain()[index];
      console.log("val = ", val);
  
        return val

        // return ypos
        
      // var domain = scaleY.domain()
      // console.log("domain = ", domain);
      // var range = scaleY.range()
      // console.log("range = ", range);
      // var scale = d3.scaleQuantize().domain(range).range(domain)
      // console.log("scale = ", scale);

      // return scale(x)

    }

    // bisectCustom

    // var xpos = x

    console.log("band:", scaleY.bandwidth())
    
    // const bisecLeftC  = d3.bisector(d =&gt; scaleY(d) + scaleY.bandwidth()).left;
    const bisecLeftC  = d3.bisector(d =&gt; scaleY(d) + scaleY.bandwidth()).left;
    const bisecRightC = d3.bisector(d =&gt; scaleY(d) + scaleY.bandwidth()).right;
    
    var domain = scaleY.domain(),
        range = scaleY.range();

    // var ypos = domain[bisecLeftC(range, yTop, 0, domain.length - 1)];
    var ypos = domain[bisecLeftC(domain, yTop)];
    console.log("ypos = ", ypos);
    var ypos2 = domain[bisecRightC(domain, yBottom)]
    console.log("ypos2 = ", ypos2);

    
    // var ypos = domain[bisecLeftC(range, yTop)];
    // console.log("ypos = ", ypos);
    // var ypos2 = domain[bisecRightC(range, yBottom) - 1]
    // console.log("ypos2 = ", ypos2);
    
    
    // return {
    //     start: data[bisecLeft(data, yTop, 0, data.length - 1)].key,
    //     end: data[bisecRight(data, yBottom) - 1].key
    // };


 // console.log(invertC(yTop))
 //  console.log(invertC(yBottom))
  
  // TODO: unite into one call? 
//     if (isFunction(scale.invert)) return {
//         start: scale.invert(xLeft),
//         end: scale.invert(xRight)
//     };
  
  // console.log(scale.invert(yTop),scale.invert(yBottom))
  
    // if (isFunction(scale.invert)) return {
    //     start: scale.invert(yTop),
    //     end: scale.invert(yBottom)
    // };
  
  
   if (!isFunction(scale.bandwidth)) {
        const bisector  = d3.bisector(d =&gt; d.key);

       bisector.left(data.data, yTop)
       
        // return {
        //     start: data[bisector.left(data, yTop)].key,
        //     end: data[bisector.right(data, yBottom) - 1].key
        // };
    }
  
    const [[x0, y0], [x1, y1]] = d3.event.selection;
    // console.log(d3.event.selection)
   // value = data.filter(d =&gt; x0 &lt;= x(d.x) &amp;&amp; x(d.x) &lt; x1 &amp;&amp; y0 &lt;= y(d.y) &amp;&amp; y(d.y) &lt; y1);

    const bisecLeft  = d3.bisector(d =&gt; scale(d.key) + scale.bandwidth()).left;
    const bisecRight = d3.bisector(d =&gt; scale(d.key)).right;

    return {
        start: data[bisecLeft(data, yTop, 0, data.length - 1)].key,
        end: data[bisecRight(data, yBottom) - 1].key
    };
};


const brushUn = function(svg, extent, scale, { brushed, brushing }, data, scaleY) {
    const brushSelection = svg.select('.brush');
    let b = !brushSelection.empty()
        ? brushSelection
        : svg.append('g').attr('class', 'brush');

    const brush = d3.brush();
    const undefinedWrapper = (x, f, clean) =&gt; {
        if (x !== undefined) {
            f(x);
            if (clean) brush.move(b, null);
        }
    };


    brush
        .extent(extent);

    if (isFunction(brushed)) {
        brush.on('end', () =&gt; {
            undefinedWrapper(brushInvertUn(extent, scale, data, scaleY), brushed, true);
        });
    }

    if (isFunction(brushing)) {
        brush.on('brush', () =&gt; {
            undefinedWrapper(brushInvertUn(extent, scale, data, scaleY), brushing, false);
        });
    }

    b.call(brush);
}


/**
 *
 * @param extent
 * @param scale
 * @param data
 * @return {*[]}
 */
const brushInvertY = (extent, scale, data) =&gt; {
    if (isNull(d3.event.selection)) return;

    const [yTop, yBottom] = map
        .call(d3.event.selection, el =&gt; el - extent[0][1]);

    if (isFunction(scale.invert)) return {
        start: scale.invert(yTop),
        end: scale.invert(yBottom)
    };
  

    if (!isFunction(scale.bandwidth)) {
        const bisector  = d3.bisector(d =&gt; d.key);

        return {
            start: data[bisector.left(data, yTop)].key,
            end: data[bisector.right(data, yBottom) - 1].key
        };
    }

    const bisecLeft  = d3.bisector(d =&gt; scale(d.key) + scale.bandwidth()).left;
    const bisecRight = d3.bisector(d =&gt; scale(d.key)).right;

    return {
        start: data[bisecLeft(data, yTop, 0, data.length - 1)].key,
        end: data[bisecRight(data, yBottom) - 1].key
    };
};


/**
 *
 * @param extent
 * @param scale
 * @param data
 * @return {*[]}
 */
const brushInvertX = (extent, scale, data) =&gt; {
  
  console.log("Just data: ", data)
  
    if (isNull(d3.event.selection)) return;
    // debugger;
    const [xLeft, xRight] = map
        .call(d3.event.selection, el =&gt; el[1] - extent[0][0]);

   console.log("Scale Invert: ", scale.invert(xLeft))
  
    if (isFunction(scale.invert)) return {
        start: scale.invert(xLeft),
        end: scale.invert(xRight)
    };
  

    if (!isFunction(scale.bandwidth)) {
        const bisector = d3.bisector(d =&gt; d.key);

      // debugger;
      
      console.log("Bisector left first: ", data[bisector.left(data, xLeft)].key)
        return {
            start: data[bisector.left(data, xLeft)].key,
            end: data[bisector.right(data, xRight) - 1].key
        };
    }

    const bisecLeft  = d3.bisector(d =&gt; scale(d.key) + scale.bandwidth()).left;
    const bisecRight = d3.bisector(d =&gt; scale(d.key)).right;

  console.log("Bisector left first: ", data[bisecLeft(data, xLeft, 0, data.length - 1)].key)
  
    return {
        start: data[bisecLeft(data, xLeft, 0, data.length - 1)].key,
        end: data[bisecRight(data, xRight) - 1].key
    };
};


/**
 * https://github.com/Stalkcomrade/Vs/blob/master/src/plugins/brush.js
 * @param svg
 * @param extent
 * @param scale
 * @param data
 * @param brushed
 * @param brushing
 */
const brushX = function(svg, extent, scale, { brushed, brushing }, data) {
  // debugger;
    const brushSelection = svg.select('.brush');
    let b = !brushSelection.empty()
        ? brushSelection
        : svg.append('g').attr('class', 'brush');

    const brush = d3.brushX();
    const undefinedWrapper = (x, f, clean) =&gt; {
        if (x !== undefined) {
            f(x);
            if (clean) brush.move(b, null);
        }
    };


    brush
        .extent(extent);

    if (isFunction(brushed)) {
        brush.on('end', () =&gt; {
            undefinedWrapper(brushInvertX(extent, scale, data), brushed, true);
        });
    }

    if (isFunction(brushing)) {
        brush.on('brush', () =&gt; {
            undefinedWrapper(brushInvertX(extent, scale, data), brushing, false);
        });
    }

    b.call(brush);
}


/**
 *
 * @param svg
 * @param extent
 * @param scale
 * @param brushed
 * @param brushing
 * @param data
 */
const brushY = function(svg, extent, scale, { brushed, brushing }, data) {
    const brushSelection = svg.select('.brush');
    let b = !brushSelection.empty()
        ? brushSelection
        : svg.append('g').attr('class', 'brush');

    const brush = d3.brushY();
    const undefinedWrapper = (x, f, clean) =&gt; {
        if (x !== undefined) {
            f(x);
            if (clean) brush.move(b, null);
        }
    };


    brush
        .extent(extent);

    if (isFunction(brushed)) {
        brush.on('end', () =&gt; {
            undefinedWrapper(brushInvertY(extent, scale, data), brushed, true);
        });
    }

    if (isFunction(brushing)) {
        brush.on('brush', () =&gt; {
            undefinedWrapper(brushInvertY(extent, scale, data), brushing, false);
        });
    }

    b.call(brush);
}

vm.addToGlobalContext({
  brushInvertUn,
  brushUn,
  brushInvertY,
  brushInvertX,
  brushX,
  brushY
});
  
})</pre></div><div class="paragraph code-paragraph collapsed" data-id="XZWEtxcB" run-on-load="true" last-execution-state="success" name="zoom"><pre data-type="content" type="text/javascript" id="zoom">const vm = Codestrate.VirtualMachines.get("text/javascript");


importLib([
  "moment.min.js",
  "lodash.min.js",
  "d3.min.js"
]).then(() =&gt; {
  

/**
 * https://github.com/Stalkcomrade/Vs/blob/master/src/plugins/zoom.js
 * @param svg
 * @param zooming
 * @param zoomend
 * @param zoomstart
 * @param scaleExtent
 * @param extent
 */
const zoom = function (svg, { zooming, zoomend, zoomstart }, scaleExtent, extent) {
    const zoom = d3.zoom();

    if (isSimpleExtent(scaleExtent)) zoom.scaleExtent(scaleExtent);
    if (isExtent(extent)) svg.call(disableZoomOn, extent);

    if (isFunction(zooming))   zoom.on('zoom', zooming);
    if (isFunction(zoomend))   zoom.on('end', zoomend);
    if (isFunction(zoomstart)) zoom.on('start', zoomstart);

    svg.call(zoom);
    svg.on('dblclick.zoom', null);

    return zoom;
}

/**
 * https://github.com/Stalkcomrade/Vs/blob/master/src/plugins/disableZoomOn.js
 * @param svg
 * @param extent
 */
const disableZoomOn = (svg, extent) =&gt; {
    svg.on('mousedown', () =&gt; {
      // console.log("DISABLED ZO111OM")
        const [cx, cy] = d3.mouse(svg.node()),
            [[x0, y0], [x1, y1]] = extent;

        if (cx &lt; x0 || cx &gt; x1 || cy &gt; y1 || cy &lt; y0)
            d3.event.stopImmediatePropagation();
    });
};

vm.addToGlobalContext({
  zoom,
  disableZoomOn
});
  
})</pre></div><div class="paragraph code-paragraph" data-id="B9ubdjZB" run-on-load="true" last-execution-state="success" name="timeline-chart"><pre data-type="content" type="text/javascript" id="timeline-chart">const vm = Codestrate.VirtualMachines.get("text/javascript");

importLib([
    "moment.min.js",
    "lodash.min.js",
    "d3.min.js"
]).then(() =&gt; {

    class TimelineChart {
        
        constructor(options) {
            
            // this.selectPaddingInnerOuterY = selectPaddingInnerOuterY
            Object.assign(this, roundedRect)
            this.margin = {left: 100, top: 100, right: 50, bottom: 250}
            this.size = [1000, 1000]
            this.data = {
                scale: null,
                timer: null,
                zoom: null,
                w: null,
                svg: null,
                initScale: null
            }
            
            // create the chart
            // this.drawTimeline();
        }
        
        // testing whether class methods can assess outside of class space
        // SOLVED: they can
        testScopes() {
            return options.liveTimerTick
        };
        
        drawTimeline(dataObjectTimeline) {
            
            
        
            var ks = dataObjectTimeline // getting input from global store
          
            Object.assign(this, options)
            this.axisXLabelLaneHeight = isNull(options.axisXLabel) ? 0 : 30
            
            
            // const { dateTimeStart, dateTimeEnd, data, groups } = getTimelineGroups(cloneDeep(this.data))
            const { dateTimeStart, dateTimeEnd, data, groups } = getTimelineGroups(cloneDeep(ks))
            
            // let inspect = [dateTimeStart, dateTimeEnd, data, groups]
            // inspect.push(data)
            // inspect.push(groups)
            
            const self = this
            
            const { left = 0, top = 0, right = 0, bottom = 0 } = this.margin,
                  // [w, h] = this.getElWidthHeight(),
                  [w, h] = this.size,
                  __offset__  = this.borderWidth,
                  g_w = w - left - right - this.groupLaneWidth - 2 * __offset__,
                  g_h = h - top - bottom - this.axisXLaneHeight - this.axisXLabelLaneHeight - 2 * __offset__,
                  entryClipPathId = uuid(), groupLabelClipPathId = uuid()
            self.w = g_w
            
            // this.w = g_w
            // TODO: figure out why is it used
            // if (![g_w, g_h].every(el =&gt; el &gt; 0) || !groups.length) return;
            
            
            const groupHeight = g_h / groups.length,
                  [paddingInner, paddingOuter] = selectPaddingInnerOuterY(groupHeight);
            
            const svg = d3.create("svg")
                  .attr('width', w)
                  .attr('height', h);
            
            self.svg = svg;
            
            const defs = svg
                  .append('defs');
            
            defs
                .append('clipPath')
                .attr('id', entryClipPathId)
                .append('path')
                .attr('d', () =&gt; roundedRect(0, 0, g_w, g_h + this.axisXLaneHeight, this.borderRadius - __offset__ / 2, false, true, false, true));
            defs
                .append('clipPath')
                .attr('id', groupLabelClipPathId)
                .append('path')
                .attr('d', () =&gt; roundedRect(0, 0, this.groupLaneWidth, g_h + this.axisXLaneHeight, this.borderRadius - __offset__ / 2, true, false, true, false));
            
            
            const xScale = d3.scaleTime()
                  .domain([dateTimeStart, dateTimeEnd])
                  .range([0, g_w]);
            
            self.scale = xScale;
            self.initScale = xScale.copy();
            
            this.scale = xScale;
            this.initScale = xScale.copy();
            
            
            const yScaleBrushing = d3.scaleBand()
                  .domain(groups)
                  .rangeRound([0, g_h])
            // .paddingInner(paddingInner)
            // .paddingOuter(paddingOuter);
            
            
            
            const yScale = (i) =&gt; d3.scaleBand()
                  .range([groupHeight * (i + 1), groupHeight * i])
                  .paddingInner(paddingInner)
                  .paddingOuter(paddingOuter);
            
            // INFO: for groups identification
            // self.scaleY = yScale;
            // this.initScale = xScale.copy();
            
            const xAxis = d3
                  .axisBottom(xScale)
                  .tickSize(this.tickSize)
                  .tickPadding(this.tickPadding);
            
            svg
                .append('path')
                .attr('d', () =&gt; roundedRect(left + __offset__ / 2, top + __offset__ / 2, g_w + self.groupLaneWidth + __offset__, g_h + this.axisXLaneHeight + __offset__, this.borderRadius, true, true, true, true))
                .attr('fill', this.backgroundColor)
                .attr('stroke', this.borderColor)
                .attr('stroke-width', this.borderWidth)
                .attr('pointer-events', 'none');
            
            svg
                .append('g')
                .attr('class', 'label--group')
                .attr('clip-path', `url(#${groupLabelClipPathId})`)
                .attr('transform', `translate(${left + __offset__}, ${top + __offset__})`)
                .selectAll('text')
                .data(groups)
                .enter()
                .append('text')
                .attr('x', () =&gt; this.groupLaneWidth / 2)
                .attr('y', (d, i) =&gt;  (2 * i + 1) * groupHeight / 2 )
                .attr('dy', '0.32em')
                .attr('text-anchor', 'middle')
                .attr('font-size', this.groupLabelFontSize)
                .attr('font-weight', this.groupLabelFontWeight)
                .attr('fill-opacity', this.groupLabelFontOpacity)
                .text(d =&gt; d)
                .attr('fill', '#000');
            
            svg
                .append('g')
                .attr('class', 'line--x')
                .attr('transform', `translate(${left + __offset__}, ${top + __offset__})`)
                .selectAll('line')
                .data(groups)
                .enter()
                .append('line')
                .attr('y1', (d, i) =&gt; (i + 1) * groupHeight)
                .attr('y2', (d, i) =&gt; (i + 1) * groupHeight)
                .attr('x2', () =&gt; g_w + this.groupLaneWidth)
                .attr('stroke', this.boundingLineColor)
                .attr('stroke-width', this.boundingLineWidth);
            
            svg
                .append('g')
                .attr('class', 'line--y')
                .attr('transform', () =&gt; `translate(${left + __offset__ + this.groupLaneWidth}, ${top + __offset__})`)
                .append('line')
                .attr('y2', g_h)
                .attr('stroke', this.boundingLineColor)
                .attr('stroke-width', this.boundingLineWidth);
            
            
            const axisXLane = svg
                  .append('g')
                  .attr('transform', () =&gt; `translate(${left + this.groupLaneWidth + __offset__}, ${top + g_h + __offset__})`)
                  .attr('class', 'axis axis--x')
                  .attr('font-size', this.axisFontSize)
                  .attr('font-weight', this.axisFontWeight)
                  .attr('fill-opacity', this.axisFontOpacity);
            
            
            const axisXLabelLane = svg
                  .append('g')
                  .attr('transform', `translate(${left + __offset__},${top + g_h + this.axisXLaneHeight + 2 * __offset__})`);
            
            
            axisXLabelLane
                .append('text')
                .attr('x', () =&gt;  (g_w + this.groupLaneWidth) / 2)
                .attr('y', this.axisXLabelLaneHeight / 2)
                .attr('fill', '#000')
                .attr('dy', '0.32em')
                .attr('text-anchor', 'middle')
                .text(this.axisXLabel)
                .attr('font-size', this.axisLabelFontSize)
                .attr('font-weight', this.axisLabelFontWeight)
                .attr('fill-opacity', this.axisLabelFontOpacity);
            
            const zoomExtent = [
                [left + __offset__ + this.groupLaneWidth, top + __offset__],
                [w - right - __offset__, h - __offset__ - this.axisXLabelLaneHeight]
            ];
            
            const brushExtent = [
                [left + __offset__ + this.groupLaneWidth, top + __offset__],
                [w - right - __offset__, h - this.axisXLaneHeight - __offset__ - this.axisXLabelLaneHeight]
            ];
            
            const drawFn = drawGen(
                axisXLane,
                xAxis,
                yScale,
                data,
                groups,
                g_h,
                this.symbolSize,
                this.intervalCornerRadius,
                this.currentTimeLineColor,
                this.currentTimeLineWidth,
                this.boundingLineColor,
                this.boundingLineWidth
            );
            
            
            // const brushed = ({ start, end }) =&gt; emit(this, 'range-updated', start, end);
            const brushed = ({ start, end }) =&gt; inspect.push({start, end});
            
            const zooming = () =&gt; {
                self.scale = d3.event.transform.rescaleX(xScale);
                self.scaleY = yScaleBrushing;
                svg.call(brushUn, brushExtent, self.scale, { brushed }, {data, groups}, self.scaleY);
                
                
                g.call(drawFn, self.scale);
            };
            const zoomend = () =&gt; {
                const start = self.scale.invert(0),
                      end = self.scale.invert(g_w);
                // self.$emit('range-updated', start, end);
            };
            
            
            self.zoom = zoom(svg, { zooming, zoomend }, this.scaleExtent, zoomExtent);
            
            
            const g = svg.append('g')
                  .attr('clip-path', `url(#${entryClipPathId})`)
                  .attr('transform', () =&gt; `translate(${left + __offset__ + this.groupLaneWidth}, ${top + __offset__})`);
            
            
            g.call(drawFn, self.scale);
            
            svg.attr("id", "timeline-svg")
            
            return svg

            // Observable style
            // return {svg: svg.node(), inspect: inspect}
            // document.getElementById("timeline").appendChild(svg.node())
            
        } 
        
    }

    vm.addToGlobalContext({
        TimelineChart
    });
    
})
</pre></div><div class="paragraph code-paragraph collapsed" data-id="Gdu58vgB" name="helper-functions"><pre data-type="content" type="text/javascript" id="helper-functions">const createTransientContainer = (paragraphId) =&gt; {

  // Vue.config.ignoredElements = ['transient'];
  // Create container and instantiate template.
  const containerElement = document.createElement('transient');
  containerElement.setAttribute('id', 'vue-container');
  
 	const appTemplate = document.createElement("div")
  appTemplate.setAttribute("id", "appTemplate")
  
  containerElement.appendChild(appTemplate.cloneNode(true));
  document.querySelector("#" + paragraphId).appendChild(containerElement);
  
  return containerElement
  
}

const eraseDom = (paragraphId) =&gt; {
  
	var myNode = document.getElementById(paragraphId);
	while (myNode.firstChild) {
  	  myNode.removeChild(myNode.firstChild)
  } 
}

exports = Object.assign(exports, {createTransientContainer, eraseDom})</pre></div><div class="paragraph code-paragraph collapsed" data-id="BpbYTF7M" last-execution-state="success" run-on-load="true" name="timeline-component-full"><pre data-type="content" type="text/javascript" id="timeline-component-full">exports.drawTimeline = (paragraph, dataObjectTimeline) =&gt; {
 
const utils = require("#helper-functions")  
utils.eraseDom("vue-timeline")

var containerElement = utils.createTransientContainer("vue-timeline")

var qk = new TimelineChart()
var timelineSvg = qk.drawTimeline(dataObjectTimeline)

containerElement.children[0].appendChild(timelineSvg.node())

}</pre></div><div class="paragraph body-paragraph" data-id="R9kqVipe" name="vue-timeline"><div data-type="content" type="text/html" contenteditable="true" id="vue-timeline"></div></div><div class="paragraph code-paragraph collapsed" data-id="UTsi4PEA" name="sidebar-vis" last-execution-state="success" run-on-load="true"><pre data-type="content" type="text/javascript" id="sidebar-vis">// TODO: transient elements
const vm = Codestrate.VirtualMachines.get("text/javascript");
const drawTimeline = require("#timeline-component-full");
const containerName = "sidebarVisContainer";

exports.getView = (id) =&gt; {
    
    // get container
    // get paragraph
    let container = document.getElementById(containerName);
    var comp = document.getElementsByName(id)[0].querySelector("transient[id='vue-container']")
    // var comp = dc.querySelector("div[data-type]")
    
    let w = 400;
    let h = 200;
    let div = document.createElement("div");
    div.classList.add("viewContainer");

    // if diff component is already attached to
    // sidebar, delete it
    container.querySelector("transient[id='vue-container']") &amp;&amp;
        container.querySelector("transient[id='vue-container']").remove()
    
    if (comp) {
        
        div.style.width = w + "px";
        div.style.height = h + "px";
        
        let ratio = comp.offsetWidth / comp.offsetHeight;
        
        if (ratio &gt; 0.5) {
            
            div.classList.add("height-preferred");
            
        }
        
        container.appendChild(comp)
        
        return {w: w, h: h, content: div, view: comp};
        
    } else {
        
        let div = document.createElement("div");
        div.style.width = 180 + "px";
        div.style.height = h + "px";
        div.innerHTML = "No view";
        
        return {w: 180, h: 50, content: div};
        
    }
};



exports.showPipeline = () =&gt; {
  
  let container = document.getElementById(containerName);
  
  // console.log(container)
  
  if (!container) {
    
    container = document.createElement("transient");
    container.setAttribute("id", containerName);
    document.body.appendChild(container);
  }
  
  
  document.body.setAttribute("transient-sidebar", true);
  
};

exports.hidePipeline = () =&gt; {
  
  let container = document.getElementById(containerName); 
  document.body.setAttribute("transient-sidebar", false);
  
};



exports.timelineMode = (paragraph) =&gt; {
  
  var state = paragraph.getElementsByClassName("toggle-timeline")[0]
  
  if (!state.classList.contains("timeline-active")) {
      
      // TODO: fixme get paragraph ID
    	// updates ui
   		 
    	state.classList.add("timeline-active")
    
    // FIXME: work on accessing the timeline data properly
    // currently, working via global scope vm.context.timelineFinalDataObject
    
   		console.log("Data Object for Timeline", vm.context.timelineFinalDataObject)
    
      drawTimeline.drawTimeline(paragraph, vm.context.timelineFinalDataObject)  
      exports.showPipeline()
      exports.getView("vue-timeline")
      
      } else {
        
        	state.classList.remove("timeline-active")
          exports.hidePipeline()
  	      
      }
  
}
</pre></div><div class="paragraph code-paragraph collapsed" data-id="ZPuGX6Uc" name="vis-components-ui" run-on-load="true" last-execution-state="success"><pre data-type="content" type="text/javascript" id="vis-components-ui">const sidebarVis = require("#sidebar-vis")


importLib([
    "hammer.min.js",
    "hammer-time.min.js"
]).then(() =&gt; {

  const ParagraphUtils = require("#paragraph-utils");

  let addTimelineButton = (paragraph) =&gt; {

	let header = ParagraphUtils.getHeaderElement(paragraph);

	// Make sure to add action only once, e.g. triggered multiple times on paragraph drag and drop
	if (header.querySelector(".toggle-timeline")) {
	    return;
	}

	let toggleTimeline = document.createElement("div");
	toggleTimeline.classList.add("action");
	toggleTimeline.classList.add("toggle-timeline");
	toggleTimeline.setAttribute("tooltip", "true");
	
	let iconTimeline = document.createElement("i");
	iconTimeline.classList.add("material-icons");
	toggleTimeline.appendChild(iconTimeline);
	header.appendChild(toggleTimeline);

 
     try {
       
        [{action: toggleTimeline, desc: "toggleTimeline"}].forEach(action =&gt; {

             
       var mc = new Hammer.Manager(action.action);
             
	     mc.add(new Hammer.Tap({
	         event: "tap",
	         taps: 1
	     }));

	     mc.add(new Hammer.Press({
	         event: "longpress",
	         time: 250
	     }));
             
       mc.on("tap", () =&gt; {
       	     sidebarVis.timelineMode(paragraph);                 
	         });
               
         })
       
     } catch {
       console.log("Error!");
     }
    };

    document.liveQuerySelectorAll(".paragraph").added(paragraph =&gt; {

        // only code paragraphs
        if (!paragraph.querySelector("pre[data-type='content']")) return;

        const header = ParagraphUtils.getHeaderElement(paragraph);
        const content = ParagraphUtils.getContentElement(paragraph);

        addTimelineButton(paragraph)
    });


});
</pre></div><div class="paragraph style-paragraph collapsed" data-id="hHibAaNG" name="style-timeline"><style data-type="content" type="text/css" id="style-timeline">#timeline-svg path {
    cursor: pointer;
}
#timeline-svg .axis.axis--x .domain {
    display: none;
}
#timeline-svg text {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: pointer;
}
#timeline-svg .entry--interval--default {
    fill:#896bda;
    stroke: #896bda;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--point--default {
    fill:#896bda;
    stroke: #896bda;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--interval--error {
    fill: #ff3860;;
    stroke: #ff3860;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--point--error {
    fill: #ff3860;;
    stroke: #ff3860;
    stroke-opacity: 1; 
    cursor: pointer;
}
#timeline-svg .entry--interval--success {
    fill: #23d160;;
    stroke: #23d160;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--point--success {
    fill: #23d160;;
    stroke: #23d160;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--interval--info {
    fill: #167df0;;
    stroke: #167df0;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--point--info {
    fill: #167df0;;
    stroke: #167df0;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--interval--warn {
    fill: #ffdd57;;
    stroke: #ffdd57;
    stroke-opacity: 1;
    cursor: pointer;
}
#timeline-svg .entry--point--warn {
    fill: #ffdd57;;
    stroke: #ffdd57;
    stroke-opacity: 1;
    cursor: pointer;
}



</style></div><div class="paragraph style-paragraph collapsed" data-id="PtP4e7yu" name="vis-components-sidebar-style"><style data-type="content" type="text/css" id="vis-components-sidebar-style">body[transient-sidebar] #sidebarVisContainer {
    position: fixed;
    right: 0%;
    top: 75%;
    bottom: 0%;
    width: 100%;
    height: 40%;
    z-index: 1300;
    background-color: var(--color-primary-shade-2);
    transform: translate3d(100%, 0, 0);
    box-shadow: none;
    transition: transform var(--navigation-transition), box-shadow var(--navigation-transition);
}

body[transient-sidebar="true"] #sidebarVisContainer {
    transform: translate3d(0, 0, 0);
    box-shadow: 0 0 10px gray;
}


svg foreignObject > .viewContainer {
    display: flex;
    /* 	position: static; */
    /* 	overflow: auto; */
    overflow: hidden;
}

svg foreignObject > .viewContainer .visview {
    /* 	overflow: scroll; */
    /* 	display: flex; */
    /* 	width: 100%; */
    /* 	height: 100%; */
}



#timeline-svg {
    /* width: 50 !important;     */
    /* height: 100 !important;     */
    /* transform: translate(750px, -90px) */
}

#timeline-svg > * {
    /* transform: translate("30px", "-50px"); */
}
</style></div><div class="paragraph style-paragraph collapsed" data-id="usFFzU59" name="vis-components-ui-style"><style data-type="content" type="text/css" id="vis-components-ui-style">
html .paragraph .toggle-timeline {
    margin-left: 0px;
    margin-right: 0px;
}

html .paragraph .toggle-timeline i:after {
	content: "crop_original";
}

html .paragraph .timeline-active i:after {
	color: blue;
}</style></div></div>